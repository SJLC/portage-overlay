--- /dev/null
+++ b/drivers/gpu/drm/via_chrome9/via_chrome9_3d_reg.h
@@ -0,0 +1,407 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to
+ * whom the Software is furnished to do so, subject to the
+ * following conditions:
+ *
+ * The above copyright notice and this permission notice
+ * (including the next paragraph) shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL VIA, S3 GRAPHICS, AND/OR
+ * ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef VIA_CHROME9_3D_REG_H
+#define VIA_CHROME9_3D_REG_H
+#define getmmioregister(base, offset)      \
+	(*(__volatile__ unsigned int *)(void *)(((unsigned char *)(base)) + \
+	(offset)))
+#define setmmioregister(base, offset, val) \
+	(*(__volatile__ unsigned int *)(void *)(((unsigned char *)(base)) + \
+	(offset)) = (val))
+
+#define getmmioregisteru8(base, offset)      \
+	(*(__volatile__ unsigned char *)(void *)(((unsigned char *)(base)) + \
+	(offset)))
+#define setmmioregisteru8(base, offset, val) \
+	(*(__volatile__ unsigned char *)(void *)(((unsigned char *)(base)) + \
+	(offset)) = (val))
+
+#define bci_send(bci, value)   (*(bci)++ = (unsigned long)(value))
+#define bci_set_stream_register(bci_base, bci_index, reg_value)         \
+do {                                                                    \
+	unsigned long cmd;                                              \
+									\
+	cmd = (0x90000000                                               \
+		| (1<<16) /* stream processor register */               \
+		| (bci_index & 0x3FFC)); /* MMIO register address */    \
+	bci_send(bci_base, cmd);                                        \
+	bci_send(bci_base, reg_value);                                  \
+	} while (0)
+
+/* Command Header Type */
+
+#define INV_AGPHeader0              0xFE000000
+#define INV_AGPHeader1              0xFE010000
+#define INV_AGPHeader2              0xFE020000
+#define INV_AGPHeader3              0xFE030000
+#define INV_AGPHeader4              0xFE040000
+#define INV_AGPHeader5              0xFE050000
+#define INV_AGPHeader6              0xFE060000
+#define INV_AGPHeader7              0xFE070000
+#define INV_AGPHeader82             0xFE820000
+#define INV_AGPHeader_MASK          0xFFFF0000
+#define INV_DUMMY_MASK              0xFF000000
+
+/*send pause address of AGP ring command buffer via_chrome9 this IO port*/
+#define INV_REG_PCIPAUSE            0x294
+#define INV_REG_PCIPAUSE_ENABLE     0x4
+
+#define INV_CMDBUF_THRESHOLD     (8)
+#define INV_QW_PAUSE_ALIGN       0x40
+
+/* Transmission IO Space*/
+#define INV_REG_CR_TRANS            0x041C
+#define INV_REG_CR_BEGIN            0x0420
+#define INV_REG_CR_END              0x0438
+
+#define INV_REG_3D_TRANS            0x043C
+#define INV_REG_3D_BEGIN            0x0440
+#define INV_REG_3D_END              0x06FC
+#define INV_REG_23D_WAIT            0x326C
+/*3D / 2D ID Control (Only For Group A)*/
+#define INV_REG_2D3D_ID_CTRL     0x060
+
+
+/* Engine Status */
+
+#define INV_RB_ENG_STATUS           0x0400
+#define INV_ENG_BUSY_HQV0           0x00040000
+#define INV_ENG_BUSY_HQV1           0x00020000
+#define INV_ENG_BUSY_CR             0x00000010
+#define INV_ENG_BUSY_MPEG           0x00000008
+#define INV_ENG_BUSY_VQ             0x00000004
+#define INV_ENG_BUSY_2D             0x00000002
+#define INV_ENG_BUSY_3D             0x00001FE1
+#define INV_ENG_BUSY_ALL            		\
+	(INV_ENG_BUSY_2D | INV_ENG_BUSY_3D | INV_ENG_BUSY_CR)
+
+/* Command Queue Status*/
+#define INV_RB_VQ_STATUS            0x0448
+#define INV_VQ_FULL                 0x40000000
+
+/* AGP command buffer pointer current position*/
+#define INV_RB_AGPCMD_CURRADDR      0x043C
+
+/* AGP command buffer status*/
+#define INV_RB_AGPCMD_STATUS        0x0444
+#define INV_AGPCMD_InPause          0x80000000
+
+/*AGP command buffer pause address*/
+#define INV_RB_AGPCMD_PAUSEADDR     0x045C
+
+/*AGP command buffer jump address*/
+#define INV_RB_AGPCMD_JUMPADDR      0x0460
+
+/*AGP command buffer start address*/
+#define INV_RB_AGPCMD_STARTADDR      0x0464
+
+
+/* Constants */
+#define NUMBER_OF_EVENT_TAGS        1024
+#define NUMBER_OF_APERTURES_CLB     16
+
+/* Register definition */
+#define HW_SHADOW_ADDR              0x8520
+#define HW_GARTTABLE_ADDR           0x8540
+
+#define INV_HSWFlag_DBGMASK          0x00000FFF
+#define INV_HSWFlag_ENCODEMASK       0x007FFFF0
+#define INV_HSWFlag_ADDRSHFT         8
+#define INV_HSWFlag_DECODEMASK       			\
+	(INV_HSWFlag_ENCODEMASK << INV_HSWFlag_ADDRSHFT)
+#define INV_HSWFlag_ADDR_ENCODE(x)   0xCC000000
+#define INV_HSWFlag_ADDR_DECODE(x)    			\
+	(((unsigned int)x & INV_HSWFlag_DECODEMASK) >> INV_HSWFlag_ADDRSHFT)
+
+
+#define INV_SubA_HAGPBstL        0x60000000
+#define INV_SubA_HAGPBstH        0x61000000
+#define INV_SubA_HAGPBendL       0x62000000
+#define INV_SubA_HAGPBendH       0x63000000
+#define INV_SubA_HAGPBpL         0x64000000
+#define INV_SubA_HAGPBpID        0x65000000
+#define INV_HAGPBpID_PAUSE               0x00000000
+#define INV_HAGPBpID_JUMP                0x00000100
+#define INV_HAGPBpID_STOP                0x00000200
+
+#define INV_HAGPBpH_MASK                 0x000000FF
+#define INV_HAGPBpH_SHFT                 0
+
+#define INV_SubA_HAGPBjumpL      0x66000000
+#define INV_SubA_HAGPBjumpH      0x67000000
+#define INV_HAGPBjumpH_MASK              0x000000FF
+#define INV_HAGPBjumpH_SHFT              0
+
+#define INV_SubA_HFthRCM         0x68000000
+#define INV_HFthRCM_MASK                 0x003F0000
+#define INV_HFthRCM_SHFT                 16
+#define INV_HFthRCM_8                    0x00080000
+#define INV_HFthRCM_10                   0x000A0000
+#define INV_HFthRCM_18                   0x00120000
+#define INV_HFthRCM_24                   0x00180000
+#define INV_HFthRCM_32                   0x00200000
+
+#define INV_HAGPBClear                   0x00000008
+
+#define INV_HRSTTrig_RestoreAGP          0x00000004
+#define INV_HRSTTrig_RestoreAll          0x00000002
+#define INV_HAGPBTrig                    0x00000001
+
+#define INV_ParaSubType_MASK     0xff000000
+#define INV_ParaType_MASK        0x00ff0000
+#define INV_ParaOS_MASK          0x0000ff00
+#define INV_ParaAdr_MASK         0x000000ff
+#define INV_ParaSubType_SHIFT    24
+#define INV_ParaType_SHIFT       16
+#define INV_ParaOS_SHIFT         8
+#define INV_ParaAdr_SHIFT        0
+
+#define INV_ParaType_Vdata       0x00000000
+#define INV_ParaType_Attr        0x00010000
+#define INV_ParaType_Tex         0x00020000
+#define INV_ParaType_Pal         0x00030000
+#define INV_ParaType_FVF         0x00040000
+#define INV_ParaType_PreCR       0x00100000
+#define INV_ParaType_CR          0x00110000
+#define INV_ParaType_Cfg         0x00fe0000
+#define INV_ParaType_Dummy       0x00300000
+
+#define INV_SubType_Tex0         0x00000000
+#define INV_SubType_Tex1         0x00000001
+#define INV_SubType_Tex2         0x00000002
+#define INV_SubType_Tex3         0x00000003
+#define INV_SubType_Tex4         0x00000004
+#define INV_SubType_Tex5         0x00000005
+#define INV_SubType_Tex6         0x00000006
+#define INV_SubType_Tex7         0x00000007
+#define INV_SubType_General      0x000000fe
+#define INV_SubType_TexSample    0x00000020
+
+#define INV_HWBasL_MASK          0x00FFFFFF
+#define INV_HWBasH_MASK          0xFF000000
+#define INV_HWBasH_SHFT          24
+#define INV_HWBasL(x)            ((unsigned int)(x) & INV_HWBasL_MASK)
+#define INV_HWBasH(x)            ((unsigned int)(x) >> INV_HWBasH_SHFT)
+#define INV_HWBas256(x)          ((unsigned int)(x) >> 8)
+#define INV_HWPit32(x)           ((unsigned int)(x) >> 5)
+
+/* Read Back Register Setting */
+#define INV_SubA_HSetRBGID       	 0x02000000
+#define INV_HSetRBGID_CR                 0x00000000
+#define INV_HSetRBGID_FE                 0x00000001
+#define INV_HSetRBGID_PE                 0x00000002
+#define INV_HSetRBGID_RC                 0x00000003
+#define INV_HSetRBGID_PS                 0x00000004
+#define INV_HSetRBGID_XE                 0x00000005
+#define INV_HSetRBGID_BE                 0x00000006
+
+
+struct drm_clb_event_tag_info {
+	unsigned int *linear_address;
+	unsigned int *event_tag_linear_address;
+	int   usage[NUMBER_OF_EVENT_TAGS];
+	unsigned int   pid[NUMBER_OF_EVENT_TAGS];
+};
+
+static inline int is_agp_header(unsigned int data)
+{
+	switch (data & INV_AGPHeader_MASK) {
+	case INV_AGPHeader0:
+	case INV_AGPHeader1:
+	case INV_AGPHeader2:
+	case INV_AGPHeader3:
+	case INV_AGPHeader4:
+	case INV_AGPHeader5:
+	case INV_AGPHeader6:
+	case INV_AGPHeader7:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/*  Header0: 2D */
+#define addcmdheader0_invi(pCmd, dwcount)                       \
+{                                                               \
+	/* 4 unsigned int align, insert NULL Command for padding */    \
+	while (((unsigned long *)(pCmd)) & 0xF) {                    \
+		*(pCmd)++ = 0xCC000000;                         \
+	}                                                       \
+	*(pCmd)++ = INV_AGPHeader0;                             \
+	*(pCmd)++ = (dwcount);                                  \
+	*(pCmd)++ = 0;                                          \
+	*(pCmd)++ = (unsigned int)INV_HSWFlag_ADDR_ENCODE(pCmd);       \
+}
+
+/* Header1: 2D */
+#define addcmdheader1_invi(pCmd, dwAddr, dwcount)               \
+{                                                               \
+	/* 4 unsigned int align, insert NULL Command for padding */    \
+	while (((unsigned long *)(pCmd)) & 0xF) {                    \
+		*(pCmd)++ = 0xCC000000;                         \
+	}                                                       \
+	*(pCmd)++ = INV_AGPHeader1 | (dwAddr);                  \
+	*(pCmd)++ = (dwcount);                                  \
+	*(pCmd)++ = 0;                                          \
+	*(pCmd)++ = (unsigned int)INV_HSWFlag_ADDR_ENCODE(pCmd);       \
+}
+
+/* Header2: CR/3D */
+#define addcmdheader2_invi(pCmd, dwAddr, dwType)                \
+{                                                               \
+	/* 4 unsigned int align, insert NULL Command for padding */    \
+	while (((unsigned int)(pCmd)) & 0xF) {                        \
+		*(pCmd)++ = 0xCC000000;                         \
+	}                                                       \
+	*(pCmd)++ = INV_AGPHeader2 | ((dwAddr)+4);              \
+	*(pCmd)++ = (dwAddr);                                   \
+	*(pCmd)++ = (dwType);                                   \
+	*(pCmd)++ = (unsigned int)INV_HSWFlag_ADDR_ENCODE(pCmd);       \
+}
+
+/* Header2: CR/3D with SW Flag */
+#define addcmdheader2_swflag_invi(pCmd, dwAddr, dwType, dwSWFlag)  \
+{                                                                  \
+	/* 4 unsigned int align, insert NULL Command for padding */       \
+	while (((unsigned long *)(pCmd)) & 0xF) {			   \
+		*(pCmd)++ = 0xCC000000;                            \
+	}                                                          \
+	*(pCmd)++ = INV_AGPHeader2 | ((dwAddr)+4);                 \
+	*(pCmd)++ = (dwAddr);                                      \
+	*(pCmd)++ = (dwType);                                      \
+	*(pCmd)++ = (dwSWFlag);                                    \
+}
+
+
+/* Header3: 3D */
+#define addcmdheader3_invi(pCmd, dwType, dwstart, dwcount)      \
+{                                                               \
+	/* 4 unsigned int align, insert NULL Command for padding */    \
+	while (((unsigned long *)(pCmd)) & 0xF) {			\
+		*(pCmd)++ = 0xCC000000;                         \
+	}                                                       \
+	*(pCmd)++ = INV_AGPHeader3 | INV_REG_3D_TRANS;          \
+	*(pCmd)++ = (dwcount);                                  \
+	*(pCmd)++ = (dwType) | ((dwstart) & 0xFFFF);            \
+	*(pCmd)++ = (unsigned int)INV_HSWFlag_ADDR_ENCODE(pCmd);       \
+}
+
+/* Header3: 3D with SW Flag */
+#define addcmdheader3_swflag_invi(pCmd, dwType, dwstart, dwSWFlag, dwcount)  \
+{                                                                            \
+	/* 4 unsigned int align, insert NULL Command for padding */          \
+	while (((unsigned long *)(pCmd)) & 0xF) {                           \
+		*(pCmd)++ = 0xCC000000;                                      \
+	}                                                                    \
+	*(pCmd)++ = INV_AGPHeader3 | INV_REG_3D_TRANS;                       \
+	*(pCmd)++ = (dwcount);                                               \
+	*(pCmd)++ = (dwType) | ((dwstart) & 0xFFFF);                         \
+	*(pCmd)++ = (dwSWFlag);                                              \
+}
+
+/* Header4: DVD */
+#define addcmdheader4_invi(pCmd, dwAddr, dwcount, id)           \
+{                                                               \
+    /* 4 unsigned int align, insert NULL Command for padding */ \
+	while (((unsigned long *)(pCmd)) & 0xF) {              \
+		*(pCmd)++ = 0xCC000000;                         \
+	}                                                       \
+	*(pCmd)++ = INV_AGPHeader4 | (dwAddr);                  \
+	*(pCmd)++ = (dwcount);                                  \
+	*(pCmd)++ = (id);                                       \
+	*(pCmd)++ = 0;                                          \
+}
+
+/* Header5: DVD */
+#define addcmdheader5_invi(pCmd, dwQWcount, id)                 \
+{                                                               \
+	/* 4 unsigned int align, insert NULL Command for padding */    \
+	while (((unsigned long *)(pCmd)) & 0xF) {              \
+		*(pCmd)++ = 0xCC000000;                                 \
+	}                                                       \
+	*(pCmd)++ = INV_AGPHeader5;                             \
+	*(pCmd)++ = (dwQWcount);                                \
+	*(pCmd)++ = (id);                                       \
+	*(pCmd)++ = 0;                                          \
+}
+
+/* Header6: DEBUG */
+#define addcmdheader6_invi(pCmd)                                \
+{                                                               \
+	/* 4 unsigned int align, insert NULL Command for padding */    \
+	while (((unsigned long *)(pCmd)) & 0xF) {                    \
+		*(pCmd)++ = 0xCC000000;                         \
+	}                                                       \
+	*(pCmd)++ = INV_AGPHeader6;                             \
+	*(pCmd)++ = 0;                                          \
+	*(pCmd)++ = 0;                                          \
+	*(pCmd)++ = 0;                                          \
+}
+
+/* Header7: DMA */
+#define addcmdheader7_invi(pCmd, dwQWcount, id)                 \
+{                                                               \
+	/* 4 unsigned int align, insert NULL Command for padding */    \
+	while (((unsigned long *)(pCmd)) & 0xF) {                    \
+		*(pCmd)++ = 0xCC000000;                         \
+	}                                                       \
+	*(pCmd)++ = INV_AGPHeader7;                             \
+	*(pCmd)++ = (dwQWcount);                                \
+	*(pCmd)++ = (id);                                       \
+	*(pCmd)++ = 0;                                          \
+}
+
+/* Header82: Branch buffer */
+#define addcmdheader82_invi(pCmd, dwAddr, dwType);              \
+{                                                               \
+	/* 4 unsigned int align, insert NULL Command for padding */    \
+	while (((unsigned long *)(pCmd)) & 0xF) {                    \
+		*(pCmd)++ = 0xCC000000;                         \
+	}                                                       \
+	*(pCmd)++ = INV_AGPHeader82 | ((dwAddr)+4);             \
+	*(pCmd)++ = (dwAddr);                                   \
+	*(pCmd)++ = (dwType);                                   \
+	*(pCmd)++ = 0xCC000000;                                 \
+}
+
+
+#define add2dcmd_invi(pCmd, dwAddr, dwCmd)                  \
+{                                                           \
+	*(pCmd)++ = (dwAddr);                               \
+	*(pCmd)++ = (dwCmd);                                \
+}
+
+#define addcmddata_invi(pCmd, dwCmd)             (*(pCmd)++ = (dwCmd))
+
+#define addcmddatastream_invi(pCmdBuf, pCmd, dwcount)       \
+{                                                           \
+	memcpy((pCmdBuf), (pCmd), ((dwcount)<<2));        \
+	(pCmdBuf) += (dwcount);                             \
+}
+
+#endif
--- /dev/null
+++ b/drivers/gpu/drm/via_chrome9/via_chrome9_dma.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to
+ * whom the Software is furnished to do so, subject to the
+ * following conditions:
+ *
+ * The above copyright notice and this permission notice
+ * (including the next paragraph) shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL VIA, S3 GRAPHICS, AND/OR
+ * ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _VIA_CHROME9_DMA_H_
+#define _VIA_CHROME9_DMA_H_
+
+#define MAX_BCI_BUFFER_SIZE (16 * 1024 * 1024)
+
+enum cmd_request_type {
+	CM_REQUEST_BCI,
+	CM_REQUEST_DMA,
+	CM_REQUEST_RB,
+	CM_REQUEST_RB_FORCED_DMA,
+	CM_REQUEST_NOTAVAILABLE
+};
+
+struct cmd_get_space {
+	unsigned int            dwRequestSize;
+	enum cmd_request_type      hint;
+	__volatile__ unsigned int   *pcmddata;
+};
+
+struct cmd_release_space {
+	unsigned int  dwReleaseSize;
+};
+
+extern int via_chrome9_hw_init(struct drm_device *dev,
+	struct drm_via_chrome9_init *init);
+extern int via_chrome9_ioctl_flush(struct drm_device *dev, void *data,
+	struct drm_file *file_priv);
+extern int via_chrome9_ioctl_free(struct drm_device *dev, void *data,
+	struct drm_file *file_prev);
+extern int via_chrome9_ioctl_wait_chip_idle(struct drm_device *dev,
+	void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_flush_cache(struct drm_device *dev,
+	void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_flush(struct drm_device *dev, void *data,
+	struct drm_file *file_priv);
+extern int via_chrome9_ioctl_free(struct drm_device *dev, void *data,
+	struct drm_file *file_priv);
+extern unsigned int protect_size_value(unsigned int size); extern void 
+set_agp_double_cmd_inv(struct drm_device *dev); extern void 
+set_agp_ring_cmd_inv(struct drm_device *dev); extern void 
+via_chrome9_dma_init_inv(struct drm_device *dev);
+
+#endif
--- /dev/null
+++ b/drivers/gpu/drm/via_chrome9/via_chrome9_drv.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to
+ * whom the Software is furnished to do so, subject to the
+ * following conditions:
+ *
+ * The above copyright notice and this permission notice
+ * (including the next paragraph) shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL VIA, S3 GRAPHICS, AND/OR
+ * ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _VIA_CHROME9_DRV_H_
+#define _VIA_CHROME9_DRV_H_
+
+#include "drm_sman.h"
+#include "via_chrome9_verifier.h"
+#define DRIVER_AUTHOR	"Various"
+
+#define DRIVER_NAME		"via_chrome9"
+#define DRIVER_DESC		"VIA_CHROME9 Unichrome / Pro"
+#define DRIVER_DATE		"20080415"
+
+#define DRIVER_MAJOR		2
+#define DRIVER_MINOR		11
+#define DRIVER_PATCHLEVEL	1
+
+#define via_chrome9_FIRE_BUF_SIZE  1024
+#define via_chrome9_NUM_IRQS 4
+
+#define MAX_MEMORY_HEAPS     4
+#define NUMBER_OF_APERTURES     32
+
+/*typedef struct drm_via_chrome9_shadow_map 
+drm_via_chrome9_shadow_map_t;*/ struct drm_via_chrome9_shadow_map {
+	struct drm_map  *shadow;
+	unsigned int   shadow_size;
+	unsigned int   *shadow_handle;
+};
+
+/*typedef struct drm_via_chrome9_pagetable_map  
+*drm_via_chrome9_pagetable_map_t;
+ */
+struct drm_via_chrome9_pagetable_map {
+	unsigned int pagetable_offset;
+	unsigned int pagetable_size;
+	unsigned int *pagetable_handle;
+	unsigned int mmt_register;
+};
+
+/*typedef struct drm_via_chrome9_private drm_via_chrome9_private_t;*/ 
+struct drm_via_chrome9_private {
+	int chip_agp;
+	int chip_sub_index;
+
+	unsigned long front_offset;
+	unsigned long back_offset;
+	unsigned long depth_offset;
+	unsigned long fb_base_address;
+	unsigned long available_fb_size;
+	int usec_timeout;
+	int max_apertures;
+	struct drm_sman sman;
+	unsigned int alignment;
+	/* bit[31]:0:indicate no alignment needed,1:indicate
+	alignment needed and size is bit[0:30]*/
+
+	struct drm_map *sarea;
+	struct drm_via_chrome9_sarea *sarea_priv;
+
+	struct drm_map  *mmio;
+	struct drm_map  *hostBlt;
+	struct drm_map  *fb;
+	unsigned int agp_size;
+	unsigned int agp_offset;
+
+	struct semaphore *drm_s3g_sem;
+
+	struct drm_via_chrome9_shadow_map  shadow_map;
+	struct drm_via_chrome9_pagetable_map pagetable_map;
+
+	char *bci;
+
+	int aperture_usage[NUMBER_OF_APERTURES];
+	void *event_tag_info;
+
+	/* DMA buffer manager */
+	void *dma_manager;
+	/* Indicate agp/pcie heap initialization flag */
+	int agp_initialized;
+	/* Indicate video heap initialization flag */
+	int vram_initialized;
+
+	unsigned long pcie_vmalloc_addr;
+
+	/* pointer to device information */
+	void *dev;
+	/* if agp init fail, go ahead and force dri use PCI*/
+	enum {
+		DRM_AGP_RING_BUFFER,
+		DRM_AGP_DOUBLE_BUFFER,
+		DRM_AGP_DISABLED
+	} drm_agp_type;
+	/*end*/
+	struct drm_via_chrome9_state hc_state;
+	unsigned long *bci_buffer;
+	unsigned long pcie_vmalloc_nocache;
+	unsigned char gti_backup[13];
+	int initialized;
+
+};
+
+
+enum via_chrome9_family {
+	VIA_CHROME9_OTHER = 0,	/* Baseline */
+	VIA_CHROME9_PRO_GROUP_A,/* Another video engine and DMA commands */
+	VIA_CHROME9_DX9_0,
+	VIA_CHROME9_PCIE_GROUP
+};
+
+/* VIA_CHROME9 MMIO register access */
+#define VIA_CHROME9_BASE ((dev_priv->mmio))
+
+#define VIA_CHROME9_READ(reg)		DRM_READ32(VIA_CHROME9_BASE, reg)
+#define VIA_CHROME9_WRITE(reg, val)	DRM_WRITE32(VIA_CHROME9_BASE, reg, val)
+#define VIA_CHROME9_READ8(reg)		DRM_READ8(VIA_CHROME9_BASE, reg)
+#define VIA_CHROME9_WRITE8(reg, val)	DRM_WRITE8(VIA_CHROME9_BASE, reg, val)
+
+#endif
--- /dev/null
+++ b/drivers/gpu/drm/via_chrome9/via_chrome9_mm.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to
+ * whom the Software is furnished to do so, subject to the
+ * following conditions:
+ *
+ * The above copyright notice and this permission notice
+ * (including the next paragraph) shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL VIA, S3 GRAPHICS, AND/OR
+ * ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _VIA_CHROME9_MM_H_
+#define _VIA_CHROME9_MM_H_
+struct drm_via_chrome9_pciemem_ctrl {
+	enum {
+		pciemem_copy_from_user = 0,
+		pciemem_copy_to_user,
+		pciemem_memset,
+		} ctrl_type;
+	unsigned int pcieoffset;
+	unsigned int size;/*in Byte*/
+	unsigned char memsetdata;/*for memset*/
+	void *usermode_data;/*user mode data pointer*/
+};
+
+extern int via_chrome9_map_init(struct drm_device *dev,
+	struct drm_via_chrome9_init *init);
+extern int via_chrome9_heap_management_init(struct drm_device
+	*dev, struct drm_via_chrome9_init *init);
+extern void via_chrome9_memory_destroy_heap(struct drm_device
+	*dev, struct drm_via_chrome9_private *dev_priv);
+extern int via_chrome9_ioctl_check_vidmem_size(struct drm_device
+	*dev, void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_pciemem_ctrl(struct drm_device *dev,
+	void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_allocate_aperture(struct drm_device
+	*dev, void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_free_aperture(struct drm_device *dev,
+	void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_allocate_mem_base(struct drm_device
+	*dev, void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_allocate_mem_wrapper(
+	struct drm_device *dev,	void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_freemem_base(struct drm_device
+	*dev, void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_free_mem_wrapper(struct drm_device
+	*dev, void *data, struct drm_file *file_priv);
+extern void via_chrome9_reclaim_buffers_locked(struct drm_device
+	*dev, struct drm_file *file_priv);
+
+#endif
--- /dev/null
+++ b/drivers/gpu/drm/via_chrome9/via_chrome9_verifier.h
@@ -0,0 +1,60 @@
+/*
+* (C) 2008 by VIA Technologies, Inc. All Rights Reserved.
+* based on via_verifier.h, which is
+* Copyright 2004 The Unichrome Project. All Rights Reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a
+* copy of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sub license,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice (including the
+* next paragraph) shall be included in all copies or substantial portions
+* of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+* THE UNICHROME PROJECT, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+* OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+* THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*/
+
+#ifndef _via_chrome9_VERIFIER_H_
+#define _via_chrome9_VERIFIER_H_
+
+enum  drm_via_chrome9_sequence {
+	no_sequence = 0,
+	z_address,
+	dest_address,
+	tex_address,
+	zocclusion_address,
+	coarse_z_address,
+	fvf_address,
+	fence_cmd_address
+};
+
+struct drm_via_chrome9_state {
+	uint32_t texture_index;
+	uint32_t render_target_addr[4];
+	uint32_t render_target_pitch[4];
+	uint32_t vb_addr;
+	uint32_t fence_cmd_addr;
+	uint32_t fence_need_check;
+	enum drm_via_chrome9_sequence unfinished;
+	int agp_texture;
+	int multitex;
+	struct drm_device *dev;
+	int agp;
+	const uint32_t *buf_start;
+};
+
+extern int via_chrome9_verify_command_stream(const uint32_t *buf,
+	unsigned int size, struct drm_device *dev, int agp);
+void via_chrome9_init_command_verifier(void);
+
+#endif
--- /dev/null
+++ b/include/drm/via_chrome9_drm.h
@@ -0,0 +1,441 @@
+/*
+ * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
+ * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to
+ * whom the Software is furnished to do so, subject to the
+ * following conditions:
+ *
+ * The above copyright notice and this permission notice
+ * (including the next paragraph) shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL VIA, S3 GRAPHICS, AND/OR
+ * ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _VIA_CHROME9_DRM_H_
+#define _VIA_CHROME9_DRM_H_
+
+/* WARNING: These defines must be the same as what the Xserver uses.
+ * if you change them, you must change the defines in the Xserver.  */
+
+#ifndef _VIA_CHROME9_DEFINES_
+#define _VIA_CHROME9_DEFINES_
+
+#ifndef __KERNEL__
+#include "via_drmclient.h"
+#endif
+
+#define VIA_CHROME9_NR_SAREA_CLIPRECTS 		8
+#define VIA_CHROME9_NR_XVMC_PORTS               10
+#define VIA_CHROME9_NR_XVMC_LOCKS               5
+#define VIA_CHROME9_MAX_CACHELINE_SIZE          64
+#define XVMCLOCKPTR(saPriv,lockNo)					\
+	((__volatile__ struct drm_hw_lock *)				\
+	(((((unsigned long) (saPriv)->XvMCLockArea) + 			\
+				      (VIA_CHROME9_MAX_CACHELINE_SIZE - 1)) & \
+				     ~(VIA_CHROME9_MAX_CACHELINE_SIZE - 1)) + \
+				    VIA_CHROME9_MAX_CACHELINE_SIZE*(lockNo)))
+
+/* Each region is a minimum of 64k, and there are at most 64 of them.  
+*/ #define VIA_CHROME9_NR_TEX_REGIONS 64
+#define VIA_CHROME9_LOG_MIN_TEX_REGION_SIZE 16
+#endif
+
+#define VIA_CHROME9_UPLOAD_TEX0IMAGE  0x1	/* handled clientside */
+#define VIA_CHROME9_UPLOAD_TEX1IMAGE  0x2	/* handled clientside */
+#define VIA_CHROME9_UPLOAD_CTX        0x4
+#define VIA_CHROME9_UPLOAD_BUFFERS    0x8
+#define VIA_CHROME9_UPLOAD_TEX0       0x10
+#define VIA_CHROME9_UPLOAD_TEX1       0x20
+#define VIA_CHROME9_UPLOAD_CLIPRECTS  0x40
+#define VIA_CHROME9_UPLOAD_ALL        0xff
+
+/* VIA_CHROME9 specific ioctls */
+#define DRM_VIA_CHROME9_ALLOCMEM                    0x00
+#define DRM_VIA_CHROME9_FREEMEM                     0x01
+#define DRM_VIA_CHROME9_FREE                        0x02
+#define DRM_VIA_CHROME9_ALLOCATE_EVENT_TAG          0x03
+#define DRM_VIA_CHROME9_FREE_EVENT_TAG              0x04
+#define DRM_VIA_CHROME9_ALLOCATE_APERTURE           0x05
+#define DRM_VIA_CHROME9_FREE_APERTURE               0x06
+#define DRM_VIA_CHROME9_ALLOCATE_VIDEO_MEM          0x07
+#define DRM_VIA_CHROME9_FREE_VIDEO_MEM              0x08
+#define DRM_VIA_CHROME9_WAIT_CHIP_IDLE              0x09
+#define DRM_VIA_CHROME9_PROCESS_EXIT                0x0A
+#define DRM_VIA_CHROME9_RESTORE_PRIMARY             0x0B
+#define DRM_VIA_CHROME9_FLUSH_CACHE                 0x0C
+#define DRM_VIA_CHROME9_INIT                        0x0D
+#define DRM_VIA_CHROME9_FLUSH                       0x0E
+#define DRM_VIA_CHROME9_CHECKVIDMEMSIZE             0x0F
+#define DRM_VIA_CHROME9_PCIEMEMCTRL                 0x10
+#define DRM_VIA_CHROME9_AUTH_MAGIC	            0x11
+#define DRM_VIA_CHROME9_GET_PCI_ID	            0x12
+#define DRM_VIA_CHROME9_INIT_JUDGE		    0x16
+#define DRM_VIA_CHROME9_DMA		    0x17
+
+#define DRM_IOCTL_VIA_CHROME9_INIT                  	 \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_INIT, \
+	struct drm_via_chrome9_init)
+#define DRM_IOCTL_VIA_CHROME9_FLUSH                 \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_FLUSH, \
+	struct drm_via_chrome9_flush)
+#define DRM_IOCTL_VIA_CHROME9_FREE                  \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_FREE, int)
+#define DRM_IOCTL_VIA_CHROME9_ALLOCATE_EVENT_TAG    \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_ALLOCATE_EVENT_TAG, \
+	struct drm_event_via_chrome9_tag)
+#define DRM_IOCTL_VIA_CHROME9_FREE_EVENT_TAG        \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_FREE_EVENT_TAG, \
+	struct drm_event_via_chrome9_tag)
+#define DRM_IOCTL_VIA_CHROME9_ALLOCATE_APERTURE     \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_ALLOCATE_APERTURE, \
+	struct drm_via_chrome9_aperture)
+#define DRM_IOCTL_VIA_CHROME9_FREE_APERTURE         \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_FREE_APERTURE, \
+	struct drm_via_chrome9_aperture)
+#define DRM_IOCTL_VIA_CHROME9_ALLOCATE_VIDEO_MEM    \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_ALLOCATE_VIDEO_MEM, \
+	struct drm_via_chrome9_memory_alloc)
+#define DRM_IOCTL_VIA_CHROME9_FREE_VIDEO_MEM        \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_FREE_VIDEO_MEM, \
+	struct drm_via_chrome9_memory_alloc)
+#define DRM_IOCTL_VIA_CHROME9_WAIT_CHIP_IDLE        \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_WAIT_CHIP_IDLE, int)
+#define DRM_IOCTL_VIA_CHROME9_PROCESS_EXIT          \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_PROCESS_EXIT, int)
+#define DRM_IOCTL_VIA_CHROME9_RESTORE_PRIMARY       \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_RESTORE_PRIMARY, int)
+#define DRM_IOCTL_VIA_CHROME9_FLUSH_CACHE           \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_FLUSH_CACHE, int)
+#define DRM_IOCTL_VIA_CHROME9_ALLOCMEM       	    \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_ALLOCMEM, int)
+#define DRM_IOCTL_VIA_CHROME9_FREEMEM               \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_FREEMEM, int)
+#define DRM_IOCTL_VIA_CHROME9_CHECK_VIDMEM_SIZE     \
+	DRM_IOW(DRM_COMMAND_BASE +  DRM_VIA_CHROME9_CHECKVIDMEMSIZE, \
+	struct drm_via_chrome9_memory_alloc)
+#define DRM_IOCTL_VIA_CHROME9_PCIEMEMCTRL           \
+	DRM_IOW(DRM_COMMAND_BASE +  DRM_VIA_CHROME9_PCIEMEMCTRL,\
+	drm_via_chrome9_pciemem_ctrl_t)
+#define DRM_IOCTL_VIA_CHROME9_AUTH_MAGIC            \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_AUTH_MAGIC, drm_auth_t)
+#define DRM_IOCTL_VIA_CHROME9_GET_PCI_ID            \
+	DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_CHROME9_GET_PCI_ID, \
+	struct get_pci_id_struct)
+#define DRM_IOCTL_VIA_CHROME9_INIT_JUDGE	    \
+	DRM_IOR(DRM_COMMAND_BASE + DRM_VIA_CHROME9_INIT_JUDGE, int)
+#define DRM_IOCTL_VIA_CHROME9_DMA	    \
+	DRM_IO(DRM_COMMAND_BASE + DRM_VIA_CHROME9_DMA, int)
+
+enum S3GCHIPIDS {
+	CHIP_UNKNOWN = -1,
+	CHIP_CMODEL,    /*Model for any chip. */
+	CHIP_CLB,       /*Columbia */
+	CHIP_DST,       /*Destination */
+	CHIP_CSR,       /*Castlerock */
+	CHIP_INV,       /*Innovation (H3) */
+	CHIP_H5,        /*Innovation (H5) */
+	CHIP_H5S1,      /*Innovation (H5S1) */
+	CHIP_H6S2,      /*Innovation (H6S2) */
+	CHIP_CMS,       /*Columbia MS */
+	CHIP_METRO,     /*Metropolis */
+	CHIP_MANHATTAN, /*manhattan */
+	CHIP_MATRIX,    /*matrix */
+	CHIP_EVO,	    /*change for GCC 4.1 -add- 07.02.12*/
+	CHIP_H6S1,      /*Innovation (H6S1)*/
+	CHIP_DST2,      /*Destination-2 */
+	CHIP_LAST       /*Maximum number of chips supported. */
+};
+
+enum VIA_CHROME9CHIPBUS {
+	CHIP_PCI,
+	CHIP_AGP,
+	CHIP_PCIE
+};
+
+struct drm_via_chrome9_init {
+	enum {
+		VIA_CHROME9_INIT    = 0x01,
+		VIA_CHROME9_CLEANUP = 0x02
+	} func;
+	int chip_agp;
+	int chip_index;
+	int chip_sub_index;
+	int usec_timeout;
+	unsigned int   sarea_priv_offset;
+	unsigned int   fb_cpp;
+	unsigned int   front_offset;
+	unsigned int   back_offset;
+	unsigned int   depth_offset;
+	unsigned int   mmio_handle;
+	unsigned int   dma_handle;
+	unsigned int   fb_handle;
+	unsigned int   front_handle;
+	unsigned int   back_handle;
+	unsigned int   depth_handle;
+
+	unsigned int   fb_tex_offset;
+	unsigned int   fb_tex_size;
+
+	unsigned int   agp_tex_size;
+	unsigned int   agp_tex_handle;
+	unsigned int   shadow_size;
+	unsigned int   shadow_handle;
+	unsigned int   garttable_size;
+	unsigned int   garttable_offset;
+	unsigned long  available_fb_size;
+	unsigned long  fb_base_address;
+	unsigned int   DMA_size;
+	unsigned long  DMA_phys_address;
+	enum {
+		AGP_RING_BUFFER,
+		AGP_DOUBLE_BUFFER,
+		AGP_DISABLED
+	} agp_type;
+	unsigned int hostBlt_handle;
+};
+
+enum dma_cmd_type {
+	flush_bci = 0,
+	flush_bci_and_wait,
+	dma_kickoff,
+	flush_dma_buffer,
+	flush_dma_and_wait
+};
+
+struct drm_via_chrome9_flush {
+	enum dma_cmd_type    dma_cmd_type;
+	/* command buffer index */
+	int    cmd_idx;
+	/* command buffer offset */
+	int    cmd_offset;
+	/* command dword size,command always from beginning */
+	int    cmd_size;
+	/* if use dma kick off,it is dma kick off command */
+	unsigned long  dma_kickoff[2];
+	/* user mode DMA buffer pointer */
+	unsigned int *usermode_dma_buf;
+};
+
+struct event_value {
+	int event_low;
+	int event_high;
+};
+
+struct drm_via_chrome9_event_tag {
+	unsigned int  event_size;         /* event tag size */
+	int	 event_offset;                /* event tag id */
+	struct event_value last_sent_event_value;
+	struct event_value current_event_value;
+	int         query_mask0;
+	int         query_mask1;
+	int         query_Id1;
+};
+
+/* Indices into buf.Setup where various bits of state are mirrored per
+ * context and per buffer.  These can be fired at the card as a unit,
+ * or in a piecewise fashion as required.
+ */
+
+#define VIA_CHROME9_TEX_SETUP_SIZE 8
+
+/* Flags for clear ioctl
+ */
+#define VIA_CHROME9_FRONT   0x1
+#define VIA_CHROME9_BACK    0x2
+#define VIA_CHROME9_DEPTH   0x4
+#define VIA_CHROME9_STENCIL 0x8
+#define VIA_CHROME9_MEM_VIDEO   0	/* matches drm constant */
+#define VIA_CHROME9_MEM_AGP     1	/* matches drm constant */
+#define VIA_CHROME9_MEM_SYSTEM  2
+#define VIA_CHROME9_MEM_MIXED   3
+#define VIA_CHROME9_MEM_UNKNOWN 4
+
+struct drm_via_chrome9_agp {
+	uint32_t offset;
+	uint32_t size;
+};
+
+struct drm_via_chrome9_fb {
+	uint32_t offset;
+	uint32_t size;
+};
+
+struct drm_via_chrome9_mem {
+	uint32_t context;
+	uint32_t type;
+	uint32_t size;
+	unsigned long index;
+	unsigned long offset;
+};
+
+struct drm_via_chrome9_aperture {
+	/*IN: The frame buffer offset of the surface. */
+	int surface_offset;
+	/*IN: Surface pitch in byte, */
+	int pitch;
+	/*IN: Surface width in pixel */
+	int width;
+	/*IN: Surface height in pixel */
+	int height;
+	/*IN: Surface color format, Columbia has more color formats */
+	int color_format;
+	/*IN: Rotation degrees, only for Columbia */
+	int rotation_degree;
+	/*IN Is the PCIE Video, for MATRIX support NONLOCAL Aperture */
+	int isPCIEVIDEO;
+	/*IN: Is the surface tilled, only for Columbia */
+	int is_tiled;
+	/*IN:  Only allocate apertur, not hardware setup. */
+	int allocate_only;
+	/* OUT: linear address for aperture */
+	unsigned int *aperture_linear_address;
+	/*OUT:  The pitch of the aperture,for CPU write not for GE */
+	int aperture_pitch;
+	/*OUT: The index of the aperture */
+	int aperture_handle;
+	int apertureID;
+	/* always =0xAAAAAAAA */
+	/* Aligned surface's width(in pixel) */
+	int width_aligned;
+	/* Aligned surface's height(in pixel) */
+	int height_aligned;
+};
+
+/*
+    Some fileds of this data structure has no meaning now since
+    we have managed heap based on mechanism provided by DRM
+    Remain what it was to keep consistent with 3D driver interface. */
+struct drm_via_chrome9_memory_alloc {
+	enum {
+		memory_heap_video = 0,
+		memory_heap_agp,
+		memory_heap_pcie_video,
+		memory_heap_pcie,
+		max_memory_heaps
+	} heap_type;
+	struct {
+		void *lpL1Node;
+		unsigned int       alcL1Tag;
+		unsigned int       usageCount;
+		unsigned int       dwVersion;
+		unsigned int       dwResHandle;
+		unsigned int       dwProcessID;
+	} heap_info;
+	unsigned int flags;
+	unsigned int size;
+	unsigned int physaddress;
+	unsigned int offset;
+	unsigned int align;
+	void *linearaddress;
+};
+
+struct drm_via_chrome9_dma_init {
+	enum {
+		VIA_CHROME9_INIT_DMA = 0x01,
+		VIA_CHROME9_CLEANUP_DMA = 0x02,
+		VIA_CHROME9_DMA_INITIALIZED = 0x03
+	} func;
+
+	unsigned long offset;
+	unsigned long size;
+	unsigned long reg_pause_addr;
+};
+
+struct drm_via_chrome9_cmdbuffer {
+	char __user *buf;
+	unsigned long size;
+};
+
+/* Warning: If you change the SAREA structure you must change the 
+Xserver
+ * structure as well */
+
+struct drm_via_chrome9_tex_region {
+	unsigned char next, prev;	/* indices to form a circular LRU  */
+	unsigned char inUse;	/* owned by a client, or free? */
+	int age;		/* tracked by clients to update local LRU's */
+};
+
+struct drm_via_chrome9_sarea {
+	int page_flip;
+	int current_page;
+	unsigned int req_drawable;/* the X drawable id */
+	unsigned int req_draw_buffer;/* VIA_CHROME9_FRONT or VIA_CHROME9_BACK */
+	/* Last context that uploaded state */
+	int ctx_owner;
+};
+
+struct drm_via_chrome9_cmdbuf_size {
+	enum {
+		VIA_CHROME9_CMDBUF_SPACE = 0x01,
+		VIA_CHROME9_CMDBUF_LAG = 0x02
+	} func;
+	int wait;
+	uint32_t size;
+};
+
+struct drm_via_chrome9_dma_manager {
+	unsigned int     *addr_linear;
+	unsigned int     dmasize;
+	unsigned int     bdmaagp;
+	unsigned int     lastissuedeventtag;
+	unsigned int     *pBeg;
+	unsigned int     *pinusebyhw;
+	unsigned int     **ppinusebyhw;
+	unsigned int     *pinusebysw;
+	unsigned int     *pFree;
+	unsigned int     *pEnd;
+
+	unsigned long    pphysical;
+	unsigned int     maxkickoffsize;
+};
+
+struct get_pci_id_struct {
+	unsigned int     x;
+	unsigned int     y;
+	unsigned int     z;
+	unsigned int     f;
+};
+
+
+extern void *via_chrome9_dev_v4l;
+extern void *via_chrome9_filepriv_v4l;
+extern int via_chrome9_ioctl_wait_chip_idle(struct drm_device *dev,
+	void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_init(struct drm_device *dev,
+	void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_allocate_event_tag(struct drm_device
+	*dev, void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_free_event_tag(struct drm_device *dev,
+	void *data, struct drm_file *file_priv);
+extern int via_chrome9_driver_load(struct drm_device *dev,
+	unsigned long chipset);
+extern int via_chrome9_driver_unload(struct drm_device *dev); extern 
+int via_chrome9_ioctl_process_exit(struct drm_device *dev,
+	void *data, struct drm_file *file_priv);
+extern int via_chrome9_ioctl_restore_primary(struct drm_device *dev,
+	void *data, struct drm_file *file_priv);
+extern int  via_chrome9_drm_resume(struct pci_dev *dev); extern int  
+via_chrome9_drm_suspend(struct pci_dev *dev,
+	pm_message_t state);
+extern void __via_chrome9ke_udelay(unsigned long usecs); extern void 
+via_chrome9_lastclose(struct drm_device *dev); extern void 
+via_chrome9_preclose(struct drm_device *dev,
+	struct drm_file *file_priv);
+extern int via_chrome9_is_agp(struct drm_device *dev);
+
+
+#endif				/* _VIA_CHROME9_DRM_H_ */
