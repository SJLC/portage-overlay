Index: src/rtfgen.h
===================================================================
--- src/rtfgen.h	(revision 784)
+++ src/rtfgen.h	(working copy)
@@ -213,10 +213,34 @@
     void endTextBlock(bool);
     void lastIndexPage();
 
+    void startMemberDocOverloads() {}
+    void endMemberDocOverloads() {}
+    void startMemberDocProto() {}
+    void endMemberDocProto() {}
     void startMemberDocPrefixItem() {}
     void endMemberDocPrefixItem() {}
+    void startMemberDocTable() {}
+    void endMemberDocTable(bool) { newParagraph(); }
     void startMemberDocName(bool) {}
     void endMemberDocName() {}
+    void startMemberDocSpecifier() {}
+    void endMemberDocSpecifier() {}
+    void startMemberDocClassName() {}
+    void endMemberDocClassName() {}
+    void startMemberDocMethodName() {}
+    void endMemberDocMethodName() {}
+    void startMemberDocFunctionName() {}
+    void endMemberDocFunctionName() {}
+    void startMemberDocIdentifier() {}
+    void endMemberDocIdentifier() {}
+    void startMemberDocParamName() {}
+    void endMemberDocParamName() {}
+    void startMemberDocPunctuation() {}
+    void endMemberDocPunctuation() {}
+    void startMemberDocConstant() {}
+    void endMemberDocConstant() {}
+    void startMemberDocQualifier() {}
+    void endMemberDocQualifier() {}
     void startParameterType(bool,const char *);
     void endParameterType();
     void startParameterName(bool) {}
Index: src/mangen.h
===================================================================
--- src/mangen.h	(revision 784)
+++ src/mangen.h	(working copy)
@@ -211,10 +211,34 @@
     void endTextBlock(bool) {}
     void lastIndexPage() {}
 
+    void startMemberDocOverloads() {}
+    void endMemberDocOverloads() {}
+    void startMemberDocProto() {}
+    void endMemberDocProto() {}
     void startMemberDocPrefixItem() {}
     void endMemberDocPrefixItem() {}
+    void startMemberDocTable() {}
+    void endMemberDocTable(bool) { t << endl; firstCol=TRUE; }
     void startMemberDocName(bool) {}
     void endMemberDocName() {}
+    void startMemberDocSpecifier() {}
+    void endMemberDocSpecifier() {}
+    void startMemberDocClassName() {}
+    void endMemberDocClassName() {}
+    void startMemberDocMethodName() {}
+    void endMemberDocMethodName() {}
+    void startMemberDocFunctionName() {}
+    void endMemberDocFunctionName() {}
+    void startMemberDocIdentifier() {}
+    void endMemberDocIdentifier() {}
+    void startMemberDocParamName() {}
+    void endMemberDocParamName() {}
+    void startMemberDocPunctuation() {}
+    void endMemberDocPunctuation() {}
+    void startMemberDocConstant() {}
+    void endMemberDocConstant() {}
+    void startMemberDocQualifier() {}
+    void endMemberDocQualifier() {}
     void startParameterType(bool,const char *) {}
     void endParameterType() {}
     void startParameterName(bool) {}
Index: src/htmlgen.cpp
===================================================================
--- src/htmlgen.cpp	(revision 784)
+++ src/htmlgen.cpp	(working copy)
@@ -2058,66 +2058,259 @@
   DBG_HTML(t << "<!-- endMemberDocList -->" << endl;)
 }
 
-void HtmlGenerator::startMemberDoc(const char *,const char *,const char *,const char *,bool) 
+void HtmlGenerator::startMemberDoc(const char *,const char * name,const char *,const char *,bool) 
 { 
   DBG_HTML(t << "<!-- startMemberDoc -->" << endl;)
- 
-  t << "\n<div class=\"memitem\">" << endl;
-  t << "<div class=\"memproto\">" << endl;
+
+  t << endl << "<div class=\"memitem\">" << endl;
+  if (name != NULL && Config_getBool("SHOW_MEMBER_NAMES")) {
+    t << endl << "    <h3 class=\"memitem\">";
+    docify(name);
+    t << "</h3>" << endl;
+  }
 }
 
+void HtmlGenerator::endMemberDoc(bool /*hasArgs*/)
+{
+  DBG_HTML(t << "<!-- endMemberDoc -->" << endl;)
+
+  t << endl << "</div>" << endl;
+}
+
+void HtmlGenerator::startMemberDocOverloads()
+{
+  DBG_HTML(t << "<!-- startMemberDocOverloads -->" << endl;)
+
+  t << "  <div class=\"memoverloads\">" << endl;
+}
+
+void HtmlGenerator::endMemberDocOverloads()
+{
+  DBG_HTML(t << "<!-- endMemberDocOverloads -->" << endl;)
+
+  t << "  </div>" << endl;
+}
+
+void HtmlGenerator::startMemberDocProto()
+{
+  DBG_HTML(t << "<!-- startMemberDocProto -->" << endl;)
+
+  t << "  <div class=\"memproto\">" << endl;
+}
+
+void HtmlGenerator::endMemberDocProto()
+{
+  DBG_HTML(t << "<!-- endMemberDocProto -->" << endl;)
+
+  t << "  </div>" << endl;
+}
+
 void HtmlGenerator::startMemberDocPrefixItem()
 {
   DBG_HTML(t << "<!-- startMemberDocPrefixItem -->" << endl;)
+
   t << "<div class=\"memtemplate\">" << endl;
 }
 
 void HtmlGenerator::endMemberDocPrefixItem()
 {
   DBG_HTML(t << "<!-- endMemberDocPrefixItem -->" << endl;)
-  t << "</div>" << endl;
+
+  t << endl << "</div>" << endl;
 }
 
+void HtmlGenerator::startMemberDocTable()
+{
+  DBG_HTML(t << "<!-- startMemberDocNameTable -->" << endl;)
+
+  t << "    <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" class=\"memname\">" << endl;
+}
+
+void HtmlGenerator::endMemberDocTable(bool hasArgs)
+{
+  DBG_HTML(t << "<!-- endMemberDocTable -->" << endl;)
+
+  if (!hasArgs) t << "      </tr>" << endl;
+  t << "    </table>" << endl;
+}
+
 void HtmlGenerator::startMemberDocName(bool /*align*/)
 {
   DBG_HTML(t << "<!-- startMemberDocName -->" << endl;)
 
-  t << "      <table class=\"memname\">" << endl;
-    
-  t << "        <tr>" << endl;
-  t << "          <td class=\"memname\">";
+  t << "      <tr>" << endl;
+  t << "        <td class=\"memname\">" << endl;
 }
 
 void HtmlGenerator::endMemberDocName()
 {
   DBG_HTML(t << "<!-- endMemberDocName -->" << endl;)
-  t << "</td>" << endl;
+
+  t << endl << "        </td>" << endl;
 }
 
-void HtmlGenerator::startParameterList(bool openBracket)
+void HtmlGenerator::startMemberDocSpecifier()
 {
+  DBG_HTML(t << "<!-- startMemberDocSpecifier -->" << endl;)
+
+  t << "<span class=\"specifier\">";
+}
+
+void HtmlGenerator::endMemberDocSpecifier()
+{
+  t << "</span>";
+
+  DBG_HTML(t << "<!-- endMemberDocSpecifier -->" << endl;)
+}
+
+void HtmlGenerator::startMemberDocClassName()
+{
+  DBG_HTML(t << endl << "<!-- startMemberDocClassName -->" << endl;)
+
+  t << "          <span class=\"classname\">";
+}
+
+void HtmlGenerator::endMemberDocClassName()
+{
+  t << "</span>";
+
+  DBG_HTML(t << "<!-- endMemberDocClassName -->" << endl;)
+}
+
+void HtmlGenerator::startMemberDocMethodName()
+{
+  DBG_HTML(t << "<!-- startMemberDocFunctionName -->" << endl;)
+
+  t << "<span class=\"methodname\">";
+}
+
+void HtmlGenerator::endMemberDocMethodName()
+{
+  t << "</span>";
+
+  DBG_HTML(t << "<!-- endMemberDocMethodName -->" << endl;)
+}
+
+void HtmlGenerator::startMemberDocFunctionName()
+{
+  DBG_HTML(t << "<!-- startMemberDocFunctionName -->" << endl;)
+
+  t << "<span class=\"functionname\">";
+}
+
+void HtmlGenerator::endMemberDocFunctionName()
+{
+  t << "</span>";
+
+  DBG_HTML(t << "<!-- endMemberDocFunctionName -->" << endl;)
+}
+
+void HtmlGenerator::startMemberDocIdentifier()
+{
+  DBG_HTML(t << "<!-- startMemberDocIdentifier -->" << endl;)
+
+  t << "<span class=\"identifier\">";
+}
+
+void HtmlGenerator::endMemberDocIdentifier()
+{
+  t << "</span>";
+
+  DBG_HTML(t << "<!-- endMemberDocIdentifier -->" << endl;)
+}
+
+void HtmlGenerator::startMemberDocParamName()
+{
+  DBG_HTML(t << "<!-- startMemberDocParamName -->" << endl;)
+
+  t << "<span class=\"paramname\">";
+}
+
+void HtmlGenerator::endMemberDocParamName()
+{
+  t << "</span>";
+
+  DBG_HTML(t << "<!-- endMemberDocParamName -->" << endl;)
+}
+
+void HtmlGenerator::startMemberDocPunctuation()
+{
+  DBG_HTML(t << "<!-- startMemberDocPunctuation -->" << endl;)
+
+  t << "<span class=\"punctuation\">";
+}
+
+void HtmlGenerator::endMemberDocPunctuation()
+{
+  t << "</span>";
+
+  DBG_HTML(t << "<!-- endMemberDocPunctuation -->" << endl;)
+}
+
+void HtmlGenerator::startMemberDocConstant()
+{
+  DBG_HTML(t << "<!-- startMemberDocConstant -->" << endl;)
+
+  t << "<span class=\"constant\">";
+}
+
+void HtmlGenerator::endMemberDocConstant()
+{
+  t << "</span>";
+
+  DBG_HTML(t << "<!-- endMemberDocConstant -->" << endl;)
+}
+
+void HtmlGenerator::startMemberDocQualifier()
+{
+  DBG_HTML(t << "<!-- startMemberDocQualifier -->" << endl;)
+
+  t << "<span class=\"qualifier\">";
+}
+
+void HtmlGenerator::endMemberDocQualifier()
+{
+  t << "</span>";
+
+  DBG_HTML(t << "<!-- endMemberDocQualifier -->" << endl;)
+}
+
+void HtmlGenerator::startParameterList(bool openParen)
+{
   DBG_HTML(t << "<!-- startParameterList -->" << endl;)
-  t << "          <td>";
-  if (openBracket) t << "(";
+  t << "        <td>";
+  if (openParen)
+  {
+    startMemberDocPunctuation();
+    t << "(";
+    endMemberDocPunctuation();
+  }
   t << "</td>" << endl;
 }
 
+void HtmlGenerator::endParameterList()
+{
+  DBG_HTML(t << "<!-- endParameterList -->" << endl;)
+  t << "</td>" << endl;
+  t << "      </tr>" << endl;
+}
+
 void HtmlGenerator::startParameterType(bool first,const char *key)
 {
   if (first)
   {
     DBG_HTML(t << "<!-- startFirstParameterType -->" << endl;)
-    t << "          <td class=\"paramtype\">";
+    t << "        <td class=\"paramtype\">";
   }
   else
   {
     DBG_HTML(t << "<!-- startParameterType -->" << endl;)
-    t << "        <tr>" << endl;
-    t << "          <td class=\"paramkey\">";
+    t << "      <tr>" << endl;
+    t << "        <td class=\"paramkey\">";
     if (key) t << key;
-    t << "</td>" << endl;
-    t << "          <td></td>" << endl;
-    t << "          <td class=\"paramtype\">";
+    t << "</td>";
+    t << "        <td></td>";
+    t << "        <td class=\"paramtype\">";
   }
 }
 
@@ -2130,57 +2323,55 @@
 void HtmlGenerator::startParameterName(bool /*oneArgOnly*/)
 {
   DBG_HTML(t << "<!-- startParameterName -->" << endl;)
-  t << "          <td class=\"paramname\">";
+  t << "        <td class=\"paramname\">";
 }
 
-void HtmlGenerator::endParameterName(bool last,bool emptyList,bool closeBracket)
+void HtmlGenerator::endParameterName(bool last,bool emptyList,bool closeParen)
 {
   DBG_HTML(t << "<!-- endParameterName -->" << endl;)
   if (last)
   {
     if (emptyList)
     {
-      if (closeBracket) t << "</td><td>)";
-      t << "</td>" << endl;
-      t << "          <td>";
+      if (closeParen)
+      {
+        t << "</td><td>";
+        startMemberDocPunctuation();
+        t << ")";
+        endMemberDocPunctuation();
+      }
+      t << "</td><td>";
     }
     else
     {
       t << "&#160;</td>" << endl;
-      t << "        </tr>" << endl;
-      t << "        <tr>" << endl;
-      t << "          <td></td>" << endl;
-      t << "          <td>";
-      if (closeBracket) t << ")";
-      t << "</td>" << endl;
-      t << "          <td></td><td>";
+      t << "      </tr>" << endl;
+      t << "      <tr>" << endl;
+      t << "        <td></td>" << endl;
+      t << "        <td>";
+      if (closeParen)
+      {
+        startMemberDocPunctuation();
+        t << ")";
+        endMemberDocPunctuation();
+        t << "</td>" << endl;
+        t << "        <td colspan=\"2\">";
+      }
+      else
+      {
+        t << "</td>" << endl;
+        t << "        <td></td>" << endl;
+        t << "        <td>";
+      }
     }
   }
   else
   {
     t << "</td>" << endl;
-    t << "        </tr>" << endl;
+    t << "      </tr>" << endl;
   }
 }
 
-void HtmlGenerator::endParameterList()
-{
-  DBG_HTML(t << "<!-- endParameterList -->" << endl;)
-  t << "</td>" << endl;
-  t << "        </tr>" << endl;
-}
-
-void HtmlGenerator::endMemberDoc(bool hasArgs)     
-{ 
-  DBG_HTML(t << "<!-- endMemberDoc -->" << endl;)
-  if (!hasArgs)
-  {
-    t << "        </tr>" << endl;
-  }
-  t << "      </table>" << endl;
-  t << "</div>" << endl;
-}
-
 void HtmlGenerator::startDotGraph()
 {
   startSectionHeader(t,relPath,m_sectionCount);
@@ -2322,22 +2513,13 @@
 void HtmlGenerator::endIndent()          
 { 
   DBG_HTML(t << "<!-- endIndent -->" << endl;)
-  t << endl << "</div>" << endl << "</div>" << endl; 
+  t << endl << "</div>" << endl; 
 }
 
 void HtmlGenerator::addIndexItem(const char *,const char *)
 {
 }
 
-void HtmlGenerator::writeNonBreakableSpace(int n)
-{
-  int i;
-  for (i=0;i<n;i++)
-  {
-    t << "&#160;";
-  }
-}
-
 void HtmlGenerator::writeLineNumber(const char *ref,const char *filename,
                                     const char *anchor,int l)
 {
Index: src/htmlgen.h
===================================================================
--- src/htmlgen.h	(revision 784)
+++ src/htmlgen.h	(working copy)
@@ -200,7 +200,7 @@
     void writeQuickLinks(bool compact,HighlightedItem hli);
     void startContents();
     void endContents();
-    void writeNonBreakableSpace(int);
+    void writeNonBreakableSpace(int n) { int i; for (i=0;i<n;i++) t << "&#160;"; }
     
     void startDescTable()
     { t << "<table border=\"0\" cellspacing=\"2\" cellpadding=\"0\">" << endl; }
@@ -233,14 +233,38 @@
     { t << "</div>"; }
     void lastIndexPage() {}
 
+    void startMemberDocOverloads();
+    void endMemberDocOverloads();
+    void startMemberDocProto();
+    void endMemberDocProto();
     void startMemberDocPrefixItem();
     void endMemberDocPrefixItem();
+    void startMemberDocTable();
+    void endMemberDocTable(bool);
     void startMemberDocName(bool);
     void endMemberDocName();
+    void startMemberDocSpecifier();
+    void endMemberDocSpecifier();
+    void startMemberDocClassName();
+    void endMemberDocClassName();
+    void startMemberDocMethodName();
+    void endMemberDocMethodName();
+    void startMemberDocFunctionName();
+    void endMemberDocFunctionName();
+    void startMemberDocIdentifier();
+    void endMemberDocIdentifier();
+    void startMemberDocParamName();
+    void endMemberDocParamName();
+    void startMemberDocPunctuation();
+    void endMemberDocPunctuation();
+    void startMemberDocConstant();
+    void endMemberDocConstant();
+    void startMemberDocQualifier();
+    void endMemberDocQualifier();
     void startParameterType(bool first,const char *key);
     void endParameterType();
     void startParameterName(bool);
-    void endParameterName(bool last,bool emptyList,bool closeBracket);
+    void endParameterName(bool last,bool emptyList,bool closeParen);
     void startParameterList(bool);
     void endParameterList();
 
Index: src/memberdef.cpp
===================================================================
--- src/memberdef.cpp	(revision 784)
+++ src/memberdef.cpp	(working copy)
@@ -209,7 +209,9 @@
       if (hasFuncPtrType) n=a->type.left(wp);
       if (md->isObjCMethod()) { n.prepend("("); n.append(")"); }
       if (!cName.isEmpty()) n=addTemplateNames(n,cd->name(),cName);
+      ol.startMemberDocSpecifier();
       linkifyText(TextGeneratorOLImpl(ol),cd,md->getBodyDef(),md->name(),n);
+      ol.endMemberDocSpecifier();
     }
     else // non-function pointer type
     {
@@ -218,7 +220,9 @@
       if (a->type!="...")
       {
         if (!cName.isEmpty()) n=addTemplateNames(n,cd->name(),cName);
+        ol.startMemberDocSpecifier();
         linkifyText(TextGeneratorOLImpl(ol),cd,md->getBodyDef(),md->name(),n);
+        ol.endMemberDocSpecifier();
       }
     }
     if (!isDefine)
@@ -245,7 +249,9 @@
       ol.startEmphasis();
       ol.enable(OutputGenerator::Man);
       if (latexOn) ol.enable(OutputGenerator::Latex);
+      ol.startMemberDocParamName();
       if (a->name.isEmpty()) ol.docify(a->type); else ol.docify(a->name);
+      ol.endMemberDocParamName();
       ol.disable(OutputGenerator::Man);
       ol.disable(OutputGenerator::Latex);
       ol.endEmphasis();
@@ -266,17 +272,25 @@
     {
       QCString n=a->defval;
       if (!cName.isEmpty()) n=addTemplateNames(n,cd->name(),cName);
+      ol.startMemberDocPunctuation();
       ol.docify(" = ");
+      ol.endMemberDocPunctuation();
 
+      ol.startMemberDocConstant();
       ol.startTypewriter();
-      linkifyText(TextGeneratorOLImpl(ol),cd,md->getBodyDef(),md->name(),n,FALSE,TRUE,TRUE); 
+      linkifyText(TextGeneratorOLImpl(ol),cd,md->getBodyDef(),md->name(),n,FALSE,TRUE,TRUE);
       ol.endTypewriter();
-
+      ol.endMemberDocConstant();
     }
     a=defArgList->next();
-    if (a) 
+    if (a) // there are more arguments
     {
-      if (!md->isObjCMethod()) ol.docify(", "); // there are more arguments
+      if (!md->isObjCMethod())
+      {
+        ol.startMemberDocPunctuation();
+        ol.docify(", ");
+        ol.endMemberDocPunctuation();
+      }
       if (!isDefine) 
       {
         QCString key;
@@ -305,7 +319,12 @@
   ol.pushGeneratorState();
   ol.disable(OutputGenerator::Html);
   ol.disable(OutputGenerator::Latex);
-  if (!md->isObjCMethod()) ol.docify(")"); // end argument list
+  if (!md->isObjCMethod())
+  {
+    ol.startMemberDocPunctuation();
+    ol.docify(")"); // end argument list
+    ol.endMemberDocPunctuation();
+  }
   ol.enableAll();
   if (htmlOn) ol.enable(OutputGenerator::Html);
   if (latexOn) ol.enable(OutputGenerator::Latex);
@@ -314,37 +333,69 @@
   ol.popGeneratorState();
   if (md->extraTypeChars())
   {
+    ol.writeNonBreakableSpace(1);
+    ol.startMemberDocQualifier();
     ol.docify(md->extraTypeChars());
+    ol.endMemberDocQualifier();
   }
   if (defArgList->constSpecifier)
   {
-    ol.docify(" const");
+    ol.writeNonBreakableSpace(1);
+    ol.startMemberDocSpecifier();
+    ol.docify("const");
+    ol.endMemberDocSpecifier();
   }
   if (defArgList->volatileSpecifier)
   {
-    ol.docify(" volatile");
+    ol.writeNonBreakableSpace(1);
+    ol.startMemberDocSpecifier();
+    ol.docify("volatile");
+    ol.endMemberDocSpecifier();
   }
   return TRUE;
 }
 
 static void writeTemplatePrefix(OutputList &ol,ArgumentList *al)
 {
-  ol.docify("template<");
+  ol.startMemberDocSpecifier();
+  ol.docify("template");
+  ol.endMemberDocSpecifier();
+  ol.startMemberDocPunctuation();
+  ol.docify("<");
+  ol.endMemberDocPunctuation();
   Argument *a=al->first();
   while (a)
   {
+    ol.startMemberDocSpecifier();
     ol.docify(a->type);
-    ol.docify(" ");
-    ol.docify(a->name);
-    if (a->defval.length()!=0)
+    ol.endMemberDocSpecifier();
+    if (!a->name.isEmpty())
     {
+      ol.docify(" ");
+      ol.startMemberDocIdentifier();
+      ol.docify(a->name);
+      ol.endMemberDocIdentifier();
+    }
+    if (!a->defval.isEmpty())
+    {
+      ol.startMemberDocPunctuation();
       ol.docify(" = ");
+      ol.endMemberDocPunctuation();
+      ol.startMemberDocConstant();
       ol.docify(a->defval);
+      ol.endMemberDocConstant();
     } 
     a=al->next();
-    if (a) ol.docify(", ");
+    if (a)
+    {
+      ol.startMemberDocPunctuation();
+      ol.docify(", ");
+      ol.endMemberDocPunctuation();
+    }
   }
-  ol.docify("> ");
+  ol.startMemberDocPunctuation();
+  ol.docify(">");
+  ol.endMemberDocPunctuation();
 }
 
 QCString extractDirection(QCString &docs)
@@ -1386,10 +1437,14 @@
       }
       QCString varName=ltype.right(ltype.length()-ir).stripWhiteSpace();
       //printf(">>>>>> indDepth=%d ltype=`%s' varName=`%s'\n",indDepth,ltype.data(),varName.data());
+      ol.startMemberDocPunctuation();
       ol.docify("}");
+      ol.endMemberDocPunctuation();
       if (varName.isEmpty() && (name().isEmpty() || name().at(0)=='@')) 
       {
-        ol.docify(";"); 
+        ol.startMemberDocPunctuation();
+        ol.docify(";");
+        ol.endMemberDocPunctuation();
       }
       endAnonScopeNeeded=TRUE;
     }
@@ -1432,6 +1487,7 @@
       ltype.prepend("(");
       ltype.append(")");
     }
+    ol.startMemberDocSpecifier();
     linkifyText(TextGeneratorOLImpl(ol), // out
                 d,                       // scope
                 getBodyDef(),            // fileScope
@@ -1439,6 +1495,7 @@
                 ltype,                   // text
                 TRUE                     // autoBreak
                );
+    ol.endMemberDocSpecifier();
   }
   bool htmlOn = ol.isEnabled(OutputGenerator::Html);
   if (htmlOn && Config_getBool("HTML_ALIGN_MEMBERS") && !ltype.isEmpty())
@@ -1464,6 +1521,72 @@
   }
 
   // *** write name
+  writeDeclarationName(ol,cd,nd,fd,gd);
+
+  // If there is no detailed description end the anchor here.
+  if (!detailsVisible && !m_impl->annMemb)
+  {
+    ol.endDoxyAnchor(cfname,anchor());
+  }
+
+  //printf("endMember %s annoClassDef=%p annEnumType=%p\n",
+  //    name().data(),annoClassDef,annEnumType);
+  ol.endMemberItem();
+  if (endAnonScopeNeeded)
+  {
+    ol.endAnonTypeScope(--s_indentLevel);
+  }
+
+  // write brief description
+  if (!briefDescription().isEmpty() && 
+      Config_getBool("BRIEF_MEMBER_DESC") 
+      /* && !annMemb */
+     )
+  {
+    ol.startMemberDescription();
+    ol.parseDoc(briefFile(),briefLine(),
+                getOuterScope()?getOuterScope():d,this,briefDescription(),
+                TRUE,FALSE,0,TRUE,FALSE);
+    if (detailsVisible)
+    {
+      ol.pushGeneratorState();
+      ol.disableAllBut(OutputGenerator::Html);
+      //ol.endEmphasis();
+      ol.docify(" ");
+      if (m_impl->group!=0 && gd==0) // forward link to the group
+      {
+        ol.startTextLink(getOutputFileBase(),anchor());
+      }
+      else // local link
+      {
+        ol.startTextLink(0,anchor());
+      }
+      ol.endTextLink();
+      //ol.startEmphasis();
+      ol.popGeneratorState();
+    }
+    // for RTF we need to add an extra empty paragraph
+    ol.pushGeneratorState();
+    ol.disableAllBut(OutputGenerator::RTF);
+    ol.startParagraph();
+    ol.endParagraph();
+    ol.popGeneratorState();
+    ol.endMemberDescription();
+  }
+  warnIfUndocumented();
+}
+
+void MemberDef::writeDeclarationName(OutputList &ol,
+                                     ClassDef *cd,
+                                     NamespaceDef *nd,
+                                     FileDef *fd,
+                                     GroupDef *gd
+                                    )
+{
+  Definition *d=0;
+  ASSERT (cd!=0 || nd!=0 || fd!=0 || gd!=0); // member should belong to something
+  if (cd) d=cd; else if (nd) d=nd; else if (fd) d=fd; else d=gd;
+
   if (!name().isEmpty() && name().at(0)!='@') // hide anonymous stuff 
   {
     //printf("Member name=`%s gd=%p md->groupDef=%p inGroup=%d isLinkable()=%d\n",name().data(),gd,getGroupDef(),inGroup,isLinkable());
@@ -1490,7 +1613,16 @@
         //printf("writeLink %s->%d\n",name.data(),hasDocumentation());
         ClassDef *rcd = cd;
         if (isReference() && m_impl->classDef) rcd = m_impl->classDef; 
+
+        if (isMethod()) ol.startMemberDocMethodName();
+        else if (isFunction()) ol.startMemberDocFunctionName();
+        else if (isVariable()) ol.startMemberDocConstant();
+        else ol.startMemberDocSpecifier();
         writeLink(ol,rcd,nd,fd,gd);
+        if (isMethod()) ol.endMemberDocMethodName();
+        else if (isFunction()) ol.endMemberDocFunctionName();
+        else if (isVariable()) ol.endMemberDocConstant();
+        else ol.endMemberDocSpecifier();
       }
     }
     else if (isDocumentedFriendClass())
@@ -1537,17 +1669,87 @@
   // *** write arguments
   if (argsString() && !isObjCMethod()) 
   {
-    if (!isDefine()) ol.writeString(" ");
-    linkifyText(TextGeneratorOLImpl(ol), // out
-                d,                       // scope
-                getBodyDef(),            // fileScope
-                name(),                  //
-                argsString(),            // text
-                m_impl->annMemb,         // autoBreak
-                TRUE,                    // external
-                FALSE,                   // keepSpaces
-                s_indentLevel
-               );
+    if (m_impl->declArgList)
+      // declaration has argument list
+    {
+      ArgumentList *declArgList = m_impl->declArgList;
+      Argument *a=declArgList->first();
+      if (a)
+      {
+        ol.startMemberDocPunctuation();
+        ol.docify("("); // start argument list
+        ol.endMemberDocPunctuation();
+      }
+      else
+      {
+        ol.startMemberDocPunctuation();
+        ol.docify("()"); // empty argument list, output innertube
+        ol.endMemberDocPunctuation();
+      }
+
+      // convert the parameter documentation into a list of @param commands
+      while (a)
+      {
+        QCString declArgType = a->type.copy();
+        QCString declArgName = a->name.copy();
+        QCString declArgDefVal = a->defval.copy();
+        //printf("\n\n\n\ntype='%s' name='%s' defval='%s'\n\n\n\n", declArgType, declArgName, declArgDefVal);
+        if (!declArgType.isEmpty())
+        {
+          ol.startMemberDocSpecifier();
+          linkifyText(TextGeneratorOLImpl(ol),d,getBodyDef(),name(),declArgType,m_impl->annMemb,TRUE,FALSE,s_indentLevel);
+          ol.endMemberDocSpecifier();
+          ol.docify(" ");
+        }
+        if (!declArgName.isEmpty())
+        {
+          ol.startMemberDocParamName();
+          linkifyText(TextGeneratorOLImpl(ol),d,getBodyDef(),name(),declArgName,m_impl->annMemb,TRUE,FALSE,s_indentLevel);
+          ol.endMemberDocParamName();
+        }
+        if (!a->array.isEmpty())
+        {
+          ol.docify(a->array);
+        }
+        if (!declArgDefVal.isEmpty())
+        {
+          ol.startMemberDocPunctuation();
+          ol.docify(" = ");
+          ol.endMemberDocPunctuation();
+          ol.startMemberDocConstant();
+          linkifyText(TextGeneratorOLImpl(ol),d,getBodyDef(),name(),declArgDefVal);
+          ol.endMemberDocConstant();
+        }
+        a=declArgList->next();
+        if (a) {
+          ol.startMemberDocPunctuation();
+          ol.docify(", ");
+          ol.endMemberDocPunctuation();
+        }
+        else
+        {
+          ol.startMemberDocPunctuation();
+          ol.docify(")"); // end argument list
+          ol.endMemberDocPunctuation();
+        }
+
+        // Clean up
+        declArgType.resize(0);
+        declArgName.resize(0);
+        declArgDefVal.resize(0);
+      }
+    } else {
+      linkifyText(TextGeneratorOLImpl(ol), // out
+                  d,                       // scope
+                  getBodyDef(),            // fileScope
+                  name(),                  //
+                  argsString(),            // text
+                  m_impl->annMemb,         // autoBreak
+                  TRUE,                    // external
+                  FALSE,                   // keepSpaces
+                  s_indentLevel
+                 );
+    }
   }
 
   // *** write exceptions
@@ -1569,20 +1771,29 @@
   {
     if (!isDefine()) 
     {
-      ol.writeString(" = "); 
+      ol.startMemberDocPunctuation();
+      ol.writeString(" = ");
+      ol.endMemberDocPunctuation();
+      ol.startMemberDocConstant();
       linkifyText(TextGeneratorOLImpl(ol),d,getBodyDef(),name(),m_impl->initializer.simplifyWhiteSpace());
+      ol.endMemberDocConstant();
     }
     else 
     {
       ol.writeNonBreakableSpace(3);
+      ol.startMemberDocConstant();
       linkifyText(TextGeneratorOLImpl(ol),d,getBodyDef(),name(),m_impl->initializer);
+      ol.endMemberDocConstant();
     }
   }
 
   if (isObjCMethod() && isImplementation())
   {
     ol.startTypewriter();
-    ol.docify(" [implementation]");
+    ol.writeNonBreakableSpace(1);
+    ol.startMemberDocQualifier();
+    ol.docify("[implementation]");
+    ol.endMemberDocQualifier();
     ol.endTypewriter();
   }
 
@@ -1590,89 +1801,63 @@
   {
       ol.writeLatexSpacing();
       ol.startTypewriter();
-      ol.docify(" [");
+      ol.writeNonBreakableSpace(1);
+      ol.startMemberDocPunctuation();
+      ol.docify("[");
+      ol.endMemberDocPunctuation();
       QStrList sl;
-      if (isGettable())  sl.append("get");
-      if (isSettable())  sl.append("set");
+      if (isGettable()) sl.append("get");
+      if (isSettable()) sl.append("set");
       const char *s=sl.first();
       while (s)
       {
-         ol.docify(s);
-         s=sl.next();
-         if (s) ol.docify(", ");
+        ol.startMemberDocIdentifier();
+        ol.docify(s);
+        ol.endMemberDocIdentifier();
+        s=sl.next();
+        if (s)
+        {
+          ol.startMemberDocPunctuation();
+          ol.docify(", ");
+          ol.endMemberDocPunctuation();
+        }
       }
+      ol.startMemberDocPunctuation();
       ol.docify("]");
+      ol.endMemberDocPunctuation();
       ol.endTypewriter();
   }
 
   if (isEvent() && (isAddable() || isRemovable() || isRaisable()))
   {
-      ol.writeLatexSpacing();
-      ol.startTypewriter();
-      ol.docify(" [");
-      QStrList sl;
-      if (isAddable())   sl.append("add");
-      if (isRemovable()) sl.append("remove");
-      if (isRaisable())  sl.append("raise");
-      const char *s=sl.first();
-      while (s)
-      {
-         ol.docify(s);
-         s=sl.next();
-         if (s) ol.docify(", ");
-      }
-      ol.docify("]");
-      ol.endTypewriter();
-  }
-
-  if (!detailsVisible && !m_impl->annMemb)
-  {
-    ol.endDoxyAnchor(cfname,anchor());
-  }
-
-  //printf("endMember %s annoClassDef=%p annEnumType=%p\n",
-  //    name().data(),annoClassDef,annEnumType);
-  ol.endMemberItem();
-  if (endAnonScopeNeeded) 
-  {
-    ol.endAnonTypeScope(--s_indentLevel);
-  }
-
-  // write brief description
-  if (!briefDescription().isEmpty() && 
-      Config_getBool("BRIEF_MEMBER_DESC") 
-      /* && !annMemb */
-     )
-  {
-    ol.startMemberDescription();
-    ol.parseDoc(briefFile(),briefLine(),
-                getOuterScope()?getOuterScope():d,this,briefDescription(),
-                TRUE,FALSE,0,TRUE,FALSE);
-    if (detailsVisible) 
+    ol.writeLatexSpacing();
+    ol.startTypewriter();
+    ol.writeNonBreakableSpace(1);
+    ol.startMemberDocPunctuation();
+    ol.docify("[");
+    ol.endMemberDocPunctuation();
+    QStrList sl;
+    if (isAddable())   sl.append("add");
+    if (isRemovable()) sl.append("remove");
+    if (isRaisable())  sl.append("raise");
+    const char *s=sl.first();
+    while (s)
     {
-      ol.pushGeneratorState();
-      ol.disableAllBut(OutputGenerator::Html);
-      //ol.endEmphasis();
-      ol.docify(" ");
-      if (m_impl->group!=0 && gd==0) // forward link to the group
+      ol.startMemberDocQualifier();
+      ol.docify(s);
+      ol.startMemberDocQualifier();
+      s=sl.next();
+      if (s)
       {
-        ol.startTextLink(getOutputFileBase(),anchor());
+        ol.startMemberDocPunctuation();
+        ol.docify(", ");
+        ol.endMemberDocPunctuation();
       }
-      else // local link
-      {
-        ol.startTextLink(0,anchor());
-      }
-      ol.endTextLink();
-      //ol.startEmphasis();
-      ol.popGeneratorState();
     }
-    // for RTF we need to add an extra empty paragraph
-    ol.pushGeneratorState();
-    ol.disableAllBut(OutputGenerator::RTF);
-      ol.startParagraph();
-      ol.endParagraph();
-    ol.popGeneratorState();
-    ol.endMemberDescription();
+    ol.startMemberDocPunctuation();
+    ol.docify("]");
+    ol.endMemberDocPunctuation();
+    ol.endTypewriter();
   }
   warnIfUndocumented();
 }
@@ -1764,27 +1949,20 @@
 /*! Writes the "detailed documentation" section of this member to
  *  all active output formats.
  */
-void MemberDef::writeDocumentation(MemberList *ml,OutputList &ol,
+void MemberDef::writeDocumentation(MemberList *ml,
+                                   OutputList &ol,
                                    const char *scName,
                                    Definition *container,
-                                   bool inGroup,
-                                   bool showEnumValues,
                                    bool showInline
                                   )
 {
-  // if this member is in a group find the real scope name.
-  bool hasParameterList = FALSE;
-  bool inFile = container->definitionType()==Definition::TypeFile;
-  bool hasDocs = isDetailedSectionVisible(inGroup,inFile);
-
   //printf("MemberDef::writeDocumentation(): name=`%s' hasDocs=`%d' containerType=%d inGroup=%d\n",
   //    name().data(),hasDocs,container->definitionType(),inGroup);
 
-  if ( !hasDocs ) return;
-  if (isEnumValue() && !showEnumValues) return;
-
   KEEP_RESIDENT_DURING_CALL;
 
+  bool hasParameterList = FALSE;
+
   SrcLangExt lang = getLanguage();
   bool optVhdl = lang==SrcLangExt_VHDL;
 
@@ -1803,25 +1981,27 @@
     // as well, so we need to make sure its label is unique.
     memAnchor.prepend("file_");
   }
-
   QCString cname  = container->name();
   QCString cfname = getOutputFileBase();
   QCString cfiname = container->getOutputFileBase();
 
   // get member name
   QCString doxyName=name();
-  // prepend scope if there is any. TODO: make this optional for C only docs
-  if (scopeName) doxyName.prepend((QCString)scopeName+"::");
+  if (scopeName &&
+      !Config_getBool("HIDE_SCOPE_NAMES") &&
+      !Config_getBool("OPTIMIZE_OUTPUT_FOR_C"))
+  {
+    doxyName.prepend((QCString)scopeName+"::");
+  }
   QCString doxyArgs=argsString();
 
   QCString ldef = definition();
-  QCString title = name();
   //printf("member `%s' def=`%s'\n",name().data(),ldef.data());
   if (isEnumerate()) 
   {
-    if (title.at(0)=='@')
+    if (name().at(0)=='@')
     {
-      ldef = title = "anonymous enum";
+      ldef = "anonymous enum";
     }
     else
     {
@@ -1858,7 +2038,7 @@
         linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef.left(i));
         vmd->writeEnumDeclaration(ol,getClassDef(),getNamespaceDef(),getFileDef(),getGroupDef());
         linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef.right(ldef.length()-i-l));
-
+        ol.startMemberDocProto();
         found=TRUE;
       }
     }
@@ -1867,78 +2047,33 @@
       //printf("Anonymous compound `%s'\n",cname.data());
       ol.startDoxyAnchor(cfname,cname,memAnchor,doxyName,doxyArgs);
       ol.startMemberDoc(ciname,name(),memAnchor,name(),showInline);
-      // search for the last anonymous compound name in the definition
+      ol.startMemberDocProto();
+      ol.startMemberDocTable();
+      ol.startMemberDocName(isObjCMethod());
+      // strip anonymous compound names from definition
       int si=ldef.find(' '),pi,ei=i+l;
       if (si==-1) si=0;
-      while ((pi=r.match(ldef,i+l,&l))!=-1) 
-      {
-        i=pi;
-        ei=i+l;
-      }
+      while ((pi=r.match(ldef,i+l,&l))!=-1) ei=i=pi+l;
       // first si characters of ldef contain compound type name
-      ol.startMemberDocName(isObjCMethod());
       ol.docify(ldef.left(si));
+      ol.startMemberDocPunctuation();
       ol.docify(" { ... } ");
+      ol.endMemberDocPunctuation();
       // last ei characters of ldef contain pointer/reference specifiers
       int ni=ldef.find("::",si);
       if (ni>=ei) ei=ni+2;
-      linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef.right(ldef.length()-ei));
+      linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef.mid(ei));
     }
   }
   else // not an enum value
   {
     ol.startDoxyAnchor(cfname,cname,memAnchor,doxyName,doxyArgs);
-    ol.startMemberDoc(ciname,name(),memAnchor,title,showInline);
+    ol.startMemberDoc(ciname,name(),memAnchor,name(),showInline);
+    ol.startMemberDocProto();
+    ol.startMemberDocTable();
 
     ClassDef *cd=getClassDef();
-    if (!Config_getBool("HIDE_SCOPE_NAMES"))
-    {
-      bool first=TRUE;
-      if (m_impl->defTmpArgLists) 
-        // definition has explicit template parameter declarations
-      {
-        QListIterator<ArgumentList> ali(*m_impl->defTmpArgLists);
-        ArgumentList *tal;
-        for (ali.toFirst();(tal=ali.current());++ali)
-        {
-          if (tal->count()>0)
-          {
-            if (!first) ol.docify(" ");
-            ol.startMemberDocPrefixItem();
-            writeTemplatePrefix(ol,tal);
-            ol.endMemberDocPrefixItem();
-          }
-        }
-      }
-      else // definition gets it template parameters from its class
-        // (since no definition was found)
-      {
-        if (cd && !isTemplateSpecialization())
-        {
-          QList<ArgumentList> tempParamLists;
-          cd->getTemplateParameterLists(tempParamLists);
-          //printf("#tempParamLists=%d\n",tempParamLists.count());
-          QListIterator<ArgumentList> ali(tempParamLists);
-          ArgumentList *tal;
-          for (ali.toFirst();(tal=ali.current());++ali)
-          {
-            if (tal->count()>0)
-            {
-              if (!first) ol.docify(" ");
-              ol.startMemberDocPrefixItem();
-              writeTemplatePrefix(ol,tal);
-              ol.endMemberDocPrefixItem();
-            }
-          }
-        }
-        if (m_impl->tArgList) // function template prefix
-        {
-          ol.startMemberDocPrefixItem();
-          writeTemplatePrefix(ol,m_impl->tArgList);
-          ol.endMemberDocPrefixItem();
-        }
-      }
-    }
+    writeTemplatePrefixDocumentation(ol,cd);
 
     ol.startMemberDocName(isObjCMethod());
     if (cd && cd->isObjectiveC())
@@ -1966,21 +2101,61 @@
       while (i>=0 && isspace((uchar)ldef.at(i))) i--;
       if (i>0)
       {
-        // insert braches around the type
+        // insert parens around the type
         QCString tmp("("+ldef.left(i+1)+")"+ldef.mid(i+1));
         ldef=tmp;
       }
       //printf("end   >%s< i=%d\n",ldef.data(),i);
       if (isStatic()) ldef.prepend("+ "); else ldef.prepend("- ");
     }
+    else
+    {
+      // Put a span around the type specifier or return value
+      int ep = ldef.findRev(' ');
+      if (ep!=-1)
+      {
+        // Take out space before pointer specifier
+        if (ldef.mid(ep-2, 2)==" *" || ldef.mid(ep-2, 2)==" &")
+        {
+          ldef.remove((uint)ep-2, 1);
+        }
 
+        ol.startMemberDocSpecifier();
+        linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef.left(ep));
+        ol.endMemberDocSpecifier();
+        ol.docify(" ");
+        ldef.remove(0, (uint)ep);
+      }
+      if (!Config_getBool("HIDE_SCOPE_NAMES")) {
+        ep = ldef.findRev("::");
+        if (ep!=-1) {
+          ldef.remove((uint)ep, 2);
+          ol.startMemberDocClassName();
+          linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef.left((uint)ep));
+          ol.endMemberDocClassName();
+          ol.startMemberDocPunctuation();
+          ol.docify("::");
+          ol.endMemberDocPunctuation();
+          ldef.remove(0, (uint)ep);
+        }
+      }
+    }
+
     if (optVhdl)
     {
       VhdlDocGen::writeVHDLTypeDocumentation(this,container,ol);
     }
     else
     {
+      if (isMethod()) ol.startMemberDocMethodName();
+      else if (isFunction()) ol.startMemberDocFunctionName();
+      else if (isVariable()) ol.startMemberDocConstant();
+      else ol.startMemberDocSpecifier();
       linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef);
+      if (isMethod()) ol.endMemberDocMethodName();
+      else if (isFunction()) ol.endMemberDocFunctionName();
+      else if (isVariable()) ol.endMemberDocConstant();
+      else ol.endMemberDocSpecifier();
       hasParameterList=writeDefArgumentList(ol,cd,scopeName,this);
     }
 
@@ -1988,13 +2163,19 @@
     {
       if (!isDefine()) 
       {
-        ol.docify(" = "); 
+        ol.startMemberDocPunctuation();
+        ol.docify(" = ");
+        ol.endMemberDocPunctuation();
+        ol.startMemberDocConstant();
         linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),m_impl->initializer.simplifyWhiteSpace());
+        ol.endMemberDocConstant();
       }
       else 
       {
         ol.writeNonBreakableSpace(3);
+        ol.startMemberDocConstant();
         linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),m_impl->initializer);
+        ol.endMemberDocConstant();
       }
     }
     if (excpString()) // add exception list
@@ -2004,108 +2185,113 @@
     }
   }
 
-  Specifier lvirt=virtualness();
+  // write the list of specifiers
+  writeQualifierList(ol,container);
 
-  if ((!isObjCMethod() || isOptional() || isRequired()) &&
-      (protection()!=Public || lvirt!=Normal ||
-       isFriend() || isRelated() || 
-       (isInline() && Config_getBool("INLINE_INFO")) ||
-       isSignal() || isSlot() ||
-       isStatic() || 
-       (m_impl->classDef && m_impl->classDef!=container && container->definitionType()==TypeClass) ||
-       (m_impl->memSpec & ~Entry::Inline)!=0 
-      )
-     )
+  if (hasParameterList) 
   {
-    // write the member specifier list
-    ol.writeLatexSpacing();
-    ol.startTypewriter();
-    ol.docify(" [");
-    QStrList sl;
-    if (optVhdl)
-    {
-      sl.append(VhdlDocGen::trTypeString(getMemberSpecifiers()));
-    }
-    else
-    {
-      if (isFriend()) sl.append("friend");
-      else if (isRelated()) sl.append("related");
-      else
-      {
-        if      (Config_getBool("INLINE_INFO") && isInline()) sl.append("inline");
-        if      (isExplicit())            sl.append("explicit");
-        if      (isMutable())             sl.append("mutable");
-        if      (isStatic())              sl.append("static");
-        if      (isGettable())            sl.append("get");
-        if      (isSettable())            sl.append("set");
-        if      (isAddable())             sl.append("add");
-        if      (isRemovable())           sl.append("remove");
-        if      (isRaisable())            sl.append("raise");
-        if      (isReadable())            sl.append("read");
-        if      (isWritable())            sl.append("write");
-        if      (isFinal())               sl.append("final");
-        if      (isAbstract())            sl.append("abstract");
-        if      (isOverride())            sl.append("override");
-        if      (isInitonly())            sl.append("initonly");
-        if      (isSealed())              sl.append("sealed");
-        if      (isNew())                 sl.append("new");
-        if      (isOptional())            sl.append("optional");
-        if      (isRequired())            sl.append("required");
-        if      (isAssign())              sl.append("assign");
-        else if (isCopy())                sl.append("copy");
-        else if (isRetain())              sl.append("retain");
+    ol.endParameterList();
+  }
+  else
+  {
+    ol.endMemberDocName();
+  }
 
-        if (!isObjCMethod())
-        {
-          if      (protection()==Protected) sl.append("protected");
-          else if (protection()==Private)   sl.append("private");
-          else if (protection()==Package)   sl.append("package");
+  ol.endMemberDocTable(hasParameterList);
+  ol.endMemberDocProto();
+  ol.endDoxyAnchor(cfname,memAnchor);
 
-          if      (lvirt==Virtual)          sl.append("virtual");
-          else if (lvirt==Pure)             sl.append("pure virtual");
-          if      (isSignal())              sl.append("signal");
-          if      (isSlot())                sl.append("slot");
-        }
-      }
-      if (m_impl->classDef && 
-          container->definitionType()==TypeClass && 
-          m_impl->classDef!=container &&
-          !isRelated()
-         ) 
-      {
-        sl.append("inherited");
-      }
-    }
-    const char *s=sl.first();
-    while (s)
-    {
-      ol.docify(s);
-      s=sl.next();
-      if (s) ol.docify(", ");
-    }
-    ol.docify("]");
-    ol.endTypewriter();
+  // write the body text
+  writeBody(ol,scName,container,FALSE);
+  ol.endMemberDoc(hasParameterList);
+}
+
+/*! Writes overloaded function/method prototype to all active output formats.
+ */
+void MemberDef::writeOverloadedFunctionProto(OutputList &ol,
+                                             const char *scName,
+                                             Definition *container
+                                            )
+{
+  QCString scopeName = getScopeName(scName,container);
+  bool hasParameterList=false;
+  QCString ldef = definition();
+  SrcLangExt lang = getLanguage();
+  bool optVhdl = lang==SrcLangExt_VHDL;
+
+  ol.startMemberDocTable();
+
+  // write template prefix
+  ClassDef *cd=getClassDef();
+  writeTemplatePrefixDocumentation(ol,cd);
+
+  // start member doc name section
+  ol.startMemberDocName(isObjCMethod());
+
+  // write the function return value
+  ldef = writeSpecifierDocumentation(ol,cd,container,ldef);
+
+  // write function name and argument list
+  if (optVhdl)
+  {
+    VhdlDocGen::writeVHDLTypeDocumentation(this,container,ol);
   }
-  else if (isObjCMethod() && isImplementation())
+  else
   {
-    ol.writeLatexSpacing();
-    ol.startTypewriter();
-    ol.docify(" [implementation]");
-    ol.endTypewriter();
+    if (isMethod()) ol.startMemberDocMethodName();
+    else if (isFunction()) ol.startMemberDocFunctionName();
+    linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef);
+    if (isMethod()) ol.endMemberDocMethodName();
+    else if (isFunction()) ol.endMemberDocFunctionName();
+    hasParameterList=writeDefArgumentList(ol,cd,scopeName,this);
   }
+
+  // write the list of specifier
+  writeQualifierList(ol,container);
+
   if (hasParameterList) 
   {
     ol.endParameterList();
-    ol.endMemberDoc(TRUE);
   }
   else
   {
     ol.endMemberDocName();
-    ol.endMemberDoc(FALSE);
   }
-  ol.endDoxyAnchor(cfname,memAnchor);
-  ol.startIndent();
 
+  ol.endMemberDocTable(hasParameterList);
+}
+
+/*! Writes the detailed description body text to all active output formats.
+ */
+void MemberDef::writeBody(OutputList &ol,
+                          const char *scName,
+                          Definition *container,
+                          bool overloaded
+                         )
+{
+  QCString scopeName = getScopeName(scName,container);
+  QCString cname  = container->name();
+  QCString ciname = container->name();
+  if (container->definitionType()==TypeGroup)
+    ciname = ((GroupDef *)container)->groupTitle();
+  QCString cfname = getOutputFileBase();
+  QCString memAnchor = getMemAnchor(container);
+  if (container->definitionType()==TypeFile && getNamespaceDef())
+  { // member is in a namespace, but is written as part of the file documentation
+    // as well, so we need to make sure its label is unique.
+    memAnchor.prepend("file_");
+  }
+  QCString doxyName=name().copy();
+  if (scopeName &&
+      !Config_getBool("HIDE_SCOPE_NAMES") &&
+      !Config_getBool("OPTIMIZE_OUTPUT_FOR_C"))
+  {
+    doxyName.prepend((QCString)scopeName+"::");
+  }
+  QCString doxyArgs=argsString();
+  SrcLangExt lang = getLanguage();
+  bool optVhdl = lang==SrcLangExt_VHDL;
+
   // FIXME:PARA
   //ol.pushGeneratorState();
   //ol.disable(OutputGenerator::RTF);
@@ -2144,13 +2330,43 @@
     docArgList = m_impl->templateMaster->argumentList();
   }
 
+  /* write overloaded function/method description */
+  if (overloaded && isFunction())
+  {
+    ol.startMemberDocProto();
+    ol.startMemberDocTable();
+    ol.startMemberDocName(TRUE);
+
+    // Write the doxyAnchor
+    ol.startDoxyAnchor(cfname,cname,memAnchor,doxyName,doxyArgs);
+    // Write the member name
+    ClassDef *cd=getClassDef();
+    // write template prefix
+    writeTemplatePrefixDocumentation(ol,cd);
+    // write the function return value
+    writeSpecifierDocumentation(ol,cd,container,definition());
+    // write the declaration
+    writeDeclarationName(ol,cd,getNamespaceDef(),getFileDef(),getGroupDef());
+    // write specifier list
+    writeQualifierList(ol,container);
+    ol.endDoxyAnchor(cfname,memAnchor);
+
+    ol.endMemberDocName();
+    ol.endMemberDocTable(TRUE);
+    ol.endMemberDocProto();
+  }
+
+  ol.pushGeneratorState();
+
+  ol.startIndent();
+
   /* write brief description */
-  if (!brief.isEmpty() && 
-      (Config_getBool("REPEAT_BRIEF") || 
+  if (!brief.isEmpty() &&
+      (Config_getBool("REPEAT_BRIEF") ||
        !Config_getBool("BRIEF_MEMBER_DESC")
-      ) 
-     )  
-  { 
+      )
+     )
+  {
     ol.startParagraph();
     ol.parseDoc(briefFile(),briefLine(),
                 getOuterScope()?getOuterScope():container,this,
@@ -2175,9 +2391,11 @@
    
     if (!inbodyDocumentation().isEmpty())
     {
+      ol.startParagraph();
       ol.parseDoc(inbodyFile(),inbodyLine(),
                   getOuterScope()?getOuterScope():container,this,
                   inbodyDocumentation()+"\n",TRUE,FALSE);
+      ol.endParagraph();
     }
   }
   else if (!brief.isEmpty() && (Config_getBool("REPEAT_BRIEF") ||
@@ -2255,9 +2473,14 @@
           ol.startDescTableTitle(); // this enables emphasis!
           ol.startDoxyAnchor(cfname,cname,fmd->anchor(),fmd->name(),fmd->argsString());
           first=FALSE;
-          //ol.startEmphasis();
-          ol.docify(fmd->name());
-          //ol.endEmphasis();
+          if (!fmd->name().isEmpty())
+          {
+            if (isMethod()) ol.startMemberDocParamName();
+            else ol.startTypewriter();
+            ol.docify(fmd->name());
+            if (isMethod()) ol.endMemberDocParamName();
+            else ol.endTypewriter();
+          }
           ol.disableAllBut(OutputGenerator::Man);
           ol.writeString(" ");
           ol.enableAll();
@@ -2521,6 +2744,118 @@
   }
 }
 
+/*! Writes the qualifier list to all active output formats.
+ */
+void MemberDef::writeQualifierList(OutputList &ol, Definition *container)
+{
+  SrcLangExt lang = getLanguage();
+  bool optVhdl = lang==SrcLangExt_VHDL;
+
+  Specifier lvirt=virtualness();
+  if ((!isObjCMethod() || isOptional() || isRequired()) &&
+      (protection()!=Public || lvirt!=Normal ||
+       isFriend() || isRelated() || 
+       (isInline() && Config_getBool("INLINE_INFO")) ||
+       isSignal() || isSlot() ||
+       isStatic() || 
+       (m_impl->classDef && m_impl->classDef!=container && container->definitionType()==TypeClass) ||
+       (m_impl->memSpec & ~Entry::Inline)!=0 
+      )
+     )
+  {
+    // write the member qualifier list
+    ol.writeLatexSpacing();
+    ol.startTypewriter();
+    ol.writeNonBreakableSpace(1);
+    ol.startMemberDocPunctuation();
+    ol.docify("[");
+    ol.endMemberDocPunctuation();
+    QStrList sl;
+    if (optVhdl)
+    {
+      sl.append(VhdlDocGen::trTypeString(getMemberSpecifiers()));
+    }
+    else
+    {
+      if (isFriend()) sl.append("friend");
+      else if (isRelated()) sl.append("related");
+      else
+      {
+        if      (Config_getBool("INLINE_INFO") && isInline()) sl.append("inline");
+        if      (isExplicit())            sl.append("explicit");
+        if      (isMutable())             sl.append("mutable");
+        if      (isStatic())              sl.append("static");
+        if      (isGettable())            sl.append("get");
+        if      (isSettable())            sl.append("set");
+        if      (isAddable())             sl.append("add");
+        if      (isRemovable())           sl.append("remove");
+        if      (isRaisable())            sl.append("raise");
+        if      (isReadable())            sl.append("read");
+        if      (isWritable())            sl.append("write");
+        if      (isFinal())               sl.append("final");
+        if      (isAbstract())            sl.append("abstract");
+        if      (isOverride())            sl.append("override");
+        if      (isInitonly())            sl.append("initonly");
+        if      (isSealed())              sl.append("sealed");
+        if      (isNew())                 sl.append("new");
+        if      (isOptional())            sl.append("optional");
+        if      (isRequired())            sl.append("required");
+        if      (isAssign())              sl.append("assign");
+        else if (isCopy())                sl.append("copy");
+        else if (isRetain())              sl.append("retain");
+
+        if (!isObjCMethod())
+        {
+          if      (protection()==Protected) sl.append("protected");
+          else if (protection()==Private)   sl.append("private");
+          else if (protection()==Package)   sl.append("package");
+
+          if      (lvirt==Virtual)          sl.append("virtual");
+          else if (lvirt==Pure)             sl.append("pure virtual");
+          if      (isSignal())              sl.append("signal");
+          if      (isSlot())                sl.append("slot");
+        }
+      }
+      if (m_impl->classDef && 
+          container->definitionType()==TypeClass && 
+          m_impl->classDef!=container &&
+          !isRelated()
+         ) 
+      {
+        sl.append("inherited");
+      }
+    }
+    const char *s=sl.first();
+    while (s)
+    {
+      ol.startMemberDocQualifier();
+      ol.docify(s);
+      ol.endMemberDocQualifier();
+      s=sl.next();
+      if (s)
+      {
+        ol.startMemberDocPunctuation();
+        ol.docify(", ");
+        ol.endMemberDocPunctuation();
+      }
+    }
+    ol.startMemberDocPunctuation();
+    ol.docify("]");
+    ol.endMemberDocPunctuation();
+    ol.endTypewriter();
+  }
+  else if (isObjCMethod() && isImplementation())
+  {
+    ol.writeLatexSpacing();
+    ol.startTypewriter();
+    ol.writeNonBreakableSpace(1);
+    ol.startMemberDocQualifier();
+    ol.docify("[implementation]");
+    ol.endMemberDocQualifier();
+    ol.endTypewriter();
+  }
+}
+
 // strip scope and field name from the type
 // example: "struct N::S.v.c" will become "struct v"
 static QCString simplifyTypeForTable(const QCString &s)
@@ -2609,6 +2944,133 @@
   ol.endInlineMemberDoc();
 }
 
+void MemberDef::writeTemplatePrefixDocumentation(OutputList &ol,ClassDef *cd)
+{
+  if (!Config_getBool("HIDE_SCOPE_NAMES"))
+  {
+    bool first=TRUE;
+    if (m_impl->defTmpArgLists)
+      // definition has explicit template parameter declarations
+    {
+      QListIterator<ArgumentList> ali(*m_impl->defTmpArgLists);
+      ArgumentList *tal;
+      for (ali.toFirst();(tal=ali.current());++ali)
+      {
+        if (tal->count()>0)
+        {
+          if (!first) ol.writeNonBreakableSpace(1);
+          ol.startMemberDocPrefixItem();
+          writeTemplatePrefix(ol,tal);
+          ol.endMemberDocPrefixItem();
+        }
+      }
+    }
+    else // definition gets it template parameters from its class
+         // (since no definition was found)
+    {
+      if (cd && !isTemplateSpecialization())
+      {
+        QList<ArgumentList> tempParamLists;
+        cd->getTemplateParameterLists(tempParamLists);
+        //printf("#tempParamLists=%d\n",tempParamLists.count());
+        QListIterator<ArgumentList> ali(tempParamLists);
+        ArgumentList *tal;
+        for (ali.toFirst();(tal=ali.current());++ali)
+        {
+          if (tal->count()>0)
+          {
+            if (!first) ol.writeNonBreakableSpace(1);
+            ol.startMemberDocPrefixItem();
+            writeTemplatePrefix(ol,tal);
+            ol.endMemberDocPrefixItem();
+          }
+        }
+      }
+      if (m_impl->tArgList) // function template prefix
+      {
+        ol.startMemberDocPrefixItem();
+        writeTemplatePrefix(ol,m_impl->tArgList);
+        ol.endMemberDocPrefixItem();
+      }
+    }
+  }
+}
+
+QCString MemberDef::writeSpecifierDocumentation(OutputList &ol,
+                                                ClassDef *cd,
+                                                Definition *container,
+                                                QCString ldef
+                                               )
+{
+  if (cd && cd->isObjectiveC())
+  {
+    // strip scope name
+    int ep = ldef.find("::");
+    if (ep!=-1)
+    {
+      int sp=ldef.findRev(' ',ep);
+      if (sp!=-1)
+      {
+        ldef=ldef.left(sp+1)+ldef.mid(ep+2);
+      }
+    }
+    // strip keywords
+    int dp = ldef.find(':');
+    if (dp!=-1)
+    {
+      ldef=ldef.left(dp+1);
+    }
+    int l=ldef.length();
+    //printf("start >%s<\n",ldef.data());
+    int i=l-1;
+    while (i>=0 && (isId(ldef.at(i)) || ldef.at(i)==':')) i--;
+    while (i>=0 && isspace((uchar)ldef.at(i))) i--;
+    if (i>0)
+    {
+      // insert parens around the type
+      QCString tmp("("+ldef.left(i+1)+")"+ldef.mid(i+1));
+      ldef=tmp;
+    }
+    //printf("end   >%s< i=%d\n",ldef.data(),i);
+    if (isStatic()) ldef.prepend("+ "); else ldef.prepend("- ");
+  }
+  else
+  {
+    // Put a span around the type specifier or return value
+    int ep = ldef.findRev(' ');
+    if (ep!=-1)
+    {
+      // Take out space before pointer specifier
+      if (ldef.mid(ep-2, 2)==" *" || ldef.mid(ep-2, 2)==" &")
+      {
+        ldef.remove((uint)ep-2, 1);
+      }
+
+      ol.startMemberDocSpecifier();
+      linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef.left(ep));
+      ol.endMemberDocSpecifier();
+      ol.docify(" ");
+      ldef.remove(0, (uint)ep);
+    }
+    if (!Config_getBool("HIDE_SCOPE_NAMES")) {
+      // Put a span around the class or namespace name and :: operator
+      ep = ldef.findRev("::");
+      if (ep!=-1) {
+        ldef.remove((uint)ep, 2);
+        ol.startMemberDocClassName();
+        linkifyText(TextGeneratorOLImpl(ol),container,getBodyDef(),name(),ldef.left((uint)ep));
+        ol.endMemberDocClassName();
+        ol.startMemberDocPunctuation();
+        ol.docify("::");
+        ol.endMemberDocPunctuation();
+        ldef.remove(0, (uint)ep);
+      }
+    }
+  }
+
+  return ldef;
+}
+
 QCString MemberDef::memberTypeName() const
 {
   makeResident();
@@ -2665,8 +3127,31 @@
   }
 }
 
+QCString MemberDef::getScopeName(const char *scName, Definition *container)
+{
+  QCString scopeName = scName;
+  if (container->definitionType()==TypeGroup)
+  {
+    if (getClassDef())          scopeName=getClassDef()->name();
+    else if (getNamespaceDef()) scopeName=getNamespaceDef()->name();
+    else if (getFileDef())      scopeName=getFileDef()->name();
+  }
 
+  return scopeName;
+}
 
+QCString MemberDef::getMemAnchor(Definition *container)
+{
+  QCString memAnchor = anchor();
+  if (container->definitionType()==TypeFile && getNamespaceDef())
+  { // member is in a namespace, but is written as part of the file documentation
+    // as well, so we need to make sure its label is unique.
+    memAnchor.prepend("file_");
+  }
+
+  return memAnchor;
+}
+
 bool MemberDef::isFriendClass() const
 {
   makeResident();
@@ -3146,13 +3631,15 @@
         Doxygen::tagFile << "      <arglist>" << convertToXML(argsString()) << "</arglist>" << endl; 
         Doxygen::tagFile << "    </member>" << endl;
       }
+      typeDecl.startMemberDocSpecifier();
       writeLink(typeDecl,cd,nd,fd,gd);
+      typeDecl.endMemberDocSpecifier();
     }
     else
     {
-      typeDecl.startBold();
+      typeDecl.startMemberDocSpecifier();
       typeDecl.docify(n);
-      typeDecl.endBold();
+      typeDecl.endMemberDocSpecifier();
     }
     typeDecl.writeChar(' ');
   }
@@ -3160,7 +3647,9 @@
   uint enumValuesPerLine = (uint)Config_getInt("ENUM_VALUES_PER_LINE");
   if (numVisibleEnumValues>0 && enumValuesPerLine>0)
   {
+    typeDecl.startMemberDocPunctuation();
     typeDecl.docify("{ ");
+    typeDecl.endMemberDocPunctuation();
     if (fmdl)
     {
       MemberDef *fmd=fmdl->first();
@@ -3194,18 +3683,26 @@
               Doxygen::tagFile << "      <arglist>" << convertToXML(fmd->argsString()) << "</arglist>" << endl; 
               Doxygen::tagFile << "    </member>" << endl;
             }
+            typeDecl.startMemberDocConstant();
             fmd->writeLink(typeDecl,cd,nd,fd,gd);
+            typeDecl.endMemberDocConstant();
           }
           else // no docs for this enum value
           {
+            typeDecl.startMemberDocConstant();
             typeDecl.startBold();
             typeDecl.docify(fmd->name());
             typeDecl.endBold();
+            typeDecl.endMemberDocConstant();
           }
           if (fmd->hasOneLineInitializer()) // enum value has initializer
           {
+            typeDecl.startMemberDocPunctuation();
             typeDecl.writeString(" = ");
+            typeDecl.endMemberDocPunctuation();
+            typeDecl.startMemberDocConstant();
             typeDecl.parseText(fmd->initializer());
+            typeDecl.endMemberDocConstant();
           }
         }
 
@@ -3213,7 +3710,9 @@
         fmd=fmdl->next();
         if (fmd && (fmdVisible=fmd->isBriefSectionVisible())) 
         {
+          typeDecl.startMemberDocPunctuation();
           typeDecl.writeString(", ");
+          typeDecl.endMemberDocPunctuation();
         }
         if (prevVisible)
         {
@@ -3231,7 +3730,9 @@
         typeDecl.popGeneratorState();
       }
     }
+    typeDecl.startMemberDocPunctuation();
     typeDecl.docify(" }");
+    typeDecl.endMemberDocPunctuation();
   }
 }
 
@@ -3314,15 +3815,13 @@
 bool MemberDef::isObjCMethod() const
 {
   makeResident();
-  if (m_impl->classDef && m_impl->classDef->isObjectiveC() && isFunction()) return TRUE;
-  return FALSE; 
+  return m_impl->classDef && m_impl->classDef->isObjectiveC() && isFunction();
 }
 
 bool MemberDef::isObjCProperty() const
 {
   makeResident();
-  if (m_impl->classDef && m_impl->classDef->isObjectiveC() && isProperty()) return TRUE;
-  return FALSE; 
+  return m_impl->classDef && m_impl->classDef->isObjectiveC() && isProperty();
 }
 
 QCString MemberDef::qualifiedName() const
@@ -3542,10 +4041,16 @@
   return m_impl->mtype==Typedef;     
 }
 
+bool MemberDef::isMethod() const
+{
+  makeResident();
+  return getClassDef() && m_impl->mtype==Function;
+}
+
 bool MemberDef::isFunction() const
-{ 
+{
   makeResident();
-  return m_impl->mtype==Function;    
+  return m_impl->mtype==Function;   
 }
 
 bool MemberDef::isFunctionPtr() const
Index: src/memberdef.h
===================================================================
--- src/memberdef.h	(revision 784)
+++ src/memberdef.h	(working copy)
@@ -127,6 +127,7 @@
     bool isEnumerate() const;
     bool isEnumValue() const;
     bool isTypedef() const;
+    bool isMethod() const;
     bool isFunction() const;
     bool isFunctionPtr() const;
     bool isDefine() const;
@@ -345,21 +346,53 @@
 
     // output generation
     void writeDeclaration(OutputList &ol,
-                   ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd,
-                   bool inGroup); 
-    void writeDocumentation(MemberList *ml,OutputList &ol,
-                            const char *scopeName,Definition *container,
-                            bool inGroup,bool showEnumValues=FALSE,bool
-                            showInline=FALSE);
+                          ClassDef *cd,
+                          NamespaceDef *nd,
+                          FileDef *fd,
+                          GroupDef *gd,
+                          bool inGroup);
+    void writeDeclarationName(OutputList &ol,
+                              ClassDef *cd,
+                              NamespaceDef *nd,
+                              FileDef *fd,
+                              GroupDef *gd
+                             );
+    void writeDocumentation(MemberList *ml,
+                            OutputList &ol,
+                            const char *scName,
+                            Definition *container,
+                            bool showInline=FALSE
+                           );
+    void writeOverloadedFunctionProto(OutputList &ol,
+                                      const char *scName,
+                                      Definition *container
+                                     );
+    void writeBody(OutputList &ol,
+                   const char *scName,
+                   Definition *container,
+                   bool overloaded
+                  );
+    void writeQualifierList(OutputList &ol,Definition *container);
     void writeMemberDocSimple(OutputList &ol,Definition *container);
+    void writeTemplatePrefixDocumentation(OutputList &ol,ClassDef *cd);
+    QCString writeSpecifierDocumentation(OutputList &ol,
+                                         ClassDef *cd,
+                                         Definition *container,
+                                         QCString ldef
+                                        );
     void warnIfUndocumented();
-    
+    QCString getScopeName(const char *scName, Definition *container);
+    QCString getMemAnchor(Definition *container);
+    QCString getCiName(Definition *container);
     MemberDef *createTemplateInstanceMember(ArgumentList *formalArgs,
-               ArgumentList *actualArgs);
-
+                                            ArgumentList *actualArgs
+                                           );
     void writeEnumDeclaration(OutputList &typeDecl,
-            ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd);
-
+                              ClassDef *cd,
+                              NamespaceDef *nd,
+                              FileDef *fd,
+                              GroupDef *gd
+                             );
     void findSectionsInDocumentation();
     
     bool visited;
Index: src/config.xml
===================================================================
--- src/config.xml	(revision 784)
+++ src/config.xml	(working copy)
@@ -402,6 +402,11 @@
 will put a list of the files that are included by a file in the documentation 
 of that file. 
 ' defval='1'/>
+    <option type='bool' id='SHOW_MEMBER_NAMES' docs='
+If the SHOW_MEMBER_NAMES tag is set to YES then Doxygen will include the 
+name of the member in the detailed description. If set to NO (the default) 
+the member name will be hidden. 
+' defval='0'/>
     <option type='bool' id='FORCE_LOCAL_INCLUDES' docs='
 If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen 
 will list include files with double quotes in the documentation 
Index: src/memberlist.cpp
===================================================================
--- src/memberlist.cpp	(revision 784)
+++ src/memberlist.cpp	(working copy)
@@ -248,8 +248,11 @@
 }
 
 void MemberList::writePlainDeclarations(OutputList &ol,
-                       ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd
-                      )
+                                        ClassDef *cd,
+                                        NamespaceDef *nd,
+                                        FileDef *fd,
+                                        GroupDef *gd
+                                       )
 {
   //printf("----- writePlainDeclaration() ----\n");
   countDecMembers();
@@ -408,9 +411,15 @@
 }
 
 void MemberList::writeDeclarations(OutputList &ol,
-             ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd,
-             const char *title,const char *subtitle, bool showEnumValues,
-             bool showInline)
+                                   ClassDef *cd,
+                                   NamespaceDef *nd,
+                                   FileDef *fd,
+                                   GroupDef *gd,
+                                   const char *title,
+                                   const char *subtitle,
+                                   bool showEnumValues,
+                                   bool showInline
+                                  )
 {
   //printf("----- writeDeclaration() this=%p ----\n",this);
   static bool optimizeVhdl = Config_getBool("OPTIMIZE_OUTPUT_VHDL");
@@ -505,8 +514,12 @@
 }
 
 void MemberList::writeDocumentation(OutputList &ol,
-                     const char *scopeName, Definition *container,
-                     const char *title,bool showEnumValues,bool showInline)
+                                    const char *scopeName,
+                                    Definition *container,
+                                    const char *title,
+                                    bool showEnumValues,
+                                    bool showInline
+                                   )
 {
   //printf("MemberList::writeDocumentation()\n");
 
@@ -521,14 +534,88 @@
     ol.endGroupHeader(showInline ? 2 : 0);
   }
   ol.startMemberDocList();
-  
+
   MemberListIterator mli(*this);
+  MemberListIterator mlj(*this);
+  MemberListIterator mlk(*this);
   MemberDef *md;
+  MemberDef *md_next;
+  QCString cur_name;
+  QCString next_name;
+
   for ( ; (md=mli.current()) ; ++mli)
   {
-    md->writeDocumentation(this,ol,scopeName,container,
-                           m_inGroup,showEnumValues,showInline);
+    // if it's an enum value and we don't show enums values, continue
+    if (md->isEnumValue() && !showEnumValues) continue;
+
+    // if there are no docs, continue
+    bool hasDocs = md->isDetailedSectionVisible(m_inGroup,
+      container->definitionType()==Definition::TypeFile);
+    if (!hasDocs) continue;
+
+    if (Config_getBool("SORT_MEMBER_DOCS") && md->isFunction())
+    {
+      // look for overloaded functions/methods
+      cur_name=md->name();
+
+      mlj = mli;
+      mlk = mli;
+
+      do
+      {
+        // detect repeated function/method names
+        ++mlj;
+        md_next = mlj.current();
+        if (md_next) next_name = md_next->name();
+      } while (md_next && cur_name == next_name);
+      --mlj; // we always increment at least once above so go back one
+
+      if (mlj>mli)
+      {
+        // function/method is overloaded
+        ol.startMemberDoc(NULL,md->name(),NULL,NULL,showInline);
+        ol.startMemberDocOverloads();
+        while (md && mli<mlj)
+        {
+          md->writeOverloadedFunctionProto(ol,scopeName,container);
+          ++mli;
+          md=mli.current();
+        }
+        md->writeOverloadedFunctionProto(ol,scopeName,container);
+        ol.endMemberDocOverloads();
+
+        mli=mlk;
+        md=mli.current();
+
+        while (md && mli<mlj)
+        {
+          hasDocs = md->isDetailedSectionVisible(m_inGroup,
+            container->definitionType()==Definition::TypeFile);
+          if (hasDocs)
+            md->writeBody(ol,scopeName,container,TRUE);
+          ++mli;
+          md=mli.current();
+        }
+        hasDocs = md->isDetailedSectionVisible(m_inGroup,
+          container->definitionType()==Definition::TypeFile);
+        if (hasDocs)
+          md->writeBody(ol,scopeName,container,TRUE);
+
+        ol.endMemberDoc(TRUE);
+      }
+      else
+      {
+        // function is not overloaded, write documentation for a single member
+        md->writeDocumentation(this,ol,scopeName,container,showInline);
+      }
+    }
+    else
+    {
+      // write the documentation for a single member
+      md->writeDocumentation(this,ol,scopeName,container,showInline);
+    }
   }
+
   if (memberGroupList)
   {
     //printf("MemberList::writeDocumentation()  --  member groups\n");
@@ -544,7 +631,7 @@
 
 // members in a table
 void MemberList::writeSimpleDocumentation(OutputList &ol,
-                     Definition *container)
+                                          Definition *container)
 {
   countDocMembers(FALSE);
   //printf("MemberList count=%d\n",numDocMembers());
@@ -562,7 +649,9 @@
 
 // separate member pages
 void MemberList::writeDocumentationPage(OutputList &ol,
-                     const char *scopeName, Definition *container)
+                                        const char *scopeName,
+                                        Definition *container
+                                       )
 {
   static bool generateTreeView = Config_getBool("GENERATE_TREEVIEW");
   MemberListIterator mli(*this);
Index: src/memberlist.h
===================================================================
--- src/memberlist.h	(revision 784)
+++ src/memberlist.h	(working copy)
@@ -137,15 +137,33 @@
     void countDecMembers(bool countEnumValues=FALSE,GroupDef *gd=0);
     void countDocMembers(bool countEnumValues=FALSE);
     void writePlainDeclarations(OutputList &ol,
-               ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd);
+                                ClassDef *cd,
+                                NamespaceDef *nd,
+                                FileDef *fd,
+                                GroupDef *gd
+                               );
     void writeDeclarations(OutputList &ol,
-               ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd,
-               const char *title,const char *subtitle,bool showEnumValues=FALSE,bool showInline=FALSE);
-    void writeDocumentation(OutputList &ol,const char *scopeName,
-               Definition *container,const char *title,bool showEnumValues=FALSE,bool showInline=FALSE);
+                           ClassDef *cd,
+                           NamespaceDef *nd,
+                           FileDef *fd,
+                           GroupDef *gd,
+                           const char *title,
+                           const char *subtitle,
+                           bool showEnumValues=FALSE,
+                           bool showInline=FALSE
+                          );
+    void writeDocumentation(OutputList &ol,
+                            const char *scopeName,
+                            Definition *container,
+                            const char *title,
+                            bool showEnumValues=FALSE,
+                            bool showInline=FALSE
+                           );
+    void writeDocumentationPage(OutputList &ol,
+                                const char *scopeName,
+                                Definition *container
+                               );
     void writeSimpleDocumentation(OutputList &ol,Definition *container);
-    void writeDocumentationPage(OutputList &ol,
-               const char *scopeName, Definition *container);
     bool declVisible() const;
     void addMemberGroup(MemberGroup *mg);
     void setInGroup(bool inGroup) { m_inGroup=inGroup; }
Index: src/latexgen.h
===================================================================
--- src/latexgen.h	(revision 784)
+++ src/latexgen.h	(working copy)
@@ -190,7 +190,6 @@
     void startContents() {}
     void endContents() {}
     void writeNonBreakableSpace(int);
-    
     void startDescTable()
     { t << "\\begin{description}" << endl; }
     void endDescTable()
@@ -218,10 +217,52 @@
     void startTextBlock(bool) {}
     void endTextBlock(bool) {}
 
+    void startMemberDocOverloads() {}
+    void endMemberDocOverloads() {}
+    void startMemberDocProto() {}
+    void endMemberDocProto() {}
     void startMemberDocPrefixItem() {}
     void endMemberDocPrefixItem() {}
+    void startMemberDocTable() {}
+    void endMemberDocTable(bool) {}
     void startMemberDocName(bool) {}
     void endMemberDocName() {}
+    void startMemberDocSpecifier()
+    { t << "\\begin{specifier}" << endl; }
+    void endMemberDocSpecifier()
+    { t << "\\end{specifier}" << endl; }
+    void startMemberDocClassName()
+    { t << "\\begin{classname}" << endl; }
+    void endMemberDocClassName()
+    { t << "\\end{classname}" << endl; }
+    void startMemberDocMethodName()
+    { t << "\\begin{methodname}" << endl; }
+    void endMemberDocMethodName()
+    { t << "\\emd{methodname}" << endl; }
+    void startMemberDocFunctionName()
+    { t << "\\begin{functionname}" << endl; }
+    void endMemberDocFunctionName()
+    { t << "\\end{functionname}" << endl; }
+    void startMemberDocIdentifier()
+    { t << "\\begin{identifier}" << endl; }
+    void endMemberDocIdentifier()
+    { t << "\\end{identifier}" << endl; }
+    void startMemberDocParamName()
+    { t << "\\begin{paramname}" << endl; }
+    void endMemberDocParamName()
+    { t << "\\end{paramname}" << endl; }
+    void startMemberDocPunctuation()
+    { t << "\\begin{punctuation}" << endl; }
+    void endMemberDocPunctuation()
+    { t << "\\end{punctuation}" << endl; }
+    void startMemberDocConstant()
+    { t << "\\begin{constant}" << endl; }
+    void endMemberDocConstant()
+    { t << "\\end{constant}" << endl; }
+    void startMemberDocQualifier()
+    { t << "\\begin{qualifier}" << endl; }
+    void endMemberDocQualifier()
+    { t << "\\begin{end}" << endl; }
     void startParameterType(bool,const char *);
     void endParameterType();
     void startParameterName(bool);
Index: src/outputlist.h
===================================================================
--- src/outputlist.h	(revision 784)
+++ src/outputlist.h	(working copy)
@@ -386,14 +386,62 @@
     { forall(&OutputGenerator::endTextBlock,paraBreak); }
     void lastIndexPage()
     { forall(&OutputGenerator::lastIndexPage); }
+    void startMemberDocOverloads()
+    { forall(&OutputGenerator::startMemberDocOverloads); }
+    void endMemberDocOverloads()
+    { forall(&OutputGenerator::endMemberDocOverloads); }
+    void startMemberDocProto()
+    { forall(&OutputGenerator::startMemberDocProto); }
+    void endMemberDocProto()
+    { forall(&OutputGenerator::endMemberDocProto); }
     void startMemberDocPrefixItem()
     { forall(&OutputGenerator::startMemberDocPrefixItem); }
     void endMemberDocPrefixItem()
     { forall(&OutputGenerator::endMemberDocPrefixItem); }
+    void startMemberDocTable()
+    { forall(&OutputGenerator::startMemberDocTable); }
+    void endMemberDocTable(bool hasArgs)
+    { forall(&OutputGenerator::endMemberDocTable,hasArgs); }
     void startMemberDocName(bool align)
     { forall(&OutputGenerator::startMemberDocName,align); }
     void endMemberDocName()
     { forall(&OutputGenerator::endMemberDocName); }
+    void startMemberDocSpecifier()
+    { forall(&OutputGenerator::startMemberDocSpecifier); }
+    void endMemberDocSpecifier()
+    { forall(&OutputGenerator::endMemberDocSpecifier); }
+    void startMemberDocClassName()
+    { forall(&OutputGenerator::startMemberDocClassName); }
+    void endMemberDocClassName()
+    { forall(&OutputGenerator::endMemberDocClassName); }
+    void startMemberDocMethodName()
+    { forall(&OutputGenerator::startMemberDocMethodName); }
+    void endMemberDocMethodName()
+    { forall(&OutputGenerator::endMemberDocMethodName); }
+    void startMemberDocFunctionName()
+    { forall(&OutputGenerator::startMemberDocFunctionName); }
+    void endMemberDocFunctionName()
+    { forall(&OutputGenerator::endMemberDocFunctionName); }
+    void startMemberDocIdentifier()
+    { forall(&OutputGenerator::startMemberDocIdentifier); }
+    void endMemberDocIdentifier()
+    { forall(&OutputGenerator::endMemberDocIdentifier); }
+    void startMemberDocParamName()
+    { forall(&OutputGenerator::startMemberDocParamName); }
+    void endMemberDocParamName()
+    { forall(&OutputGenerator::endMemberDocParamName); }
+    void startMemberDocPunctuation()
+    { forall(&OutputGenerator::startMemberDocPunctuation); }
+    void endMemberDocPunctuation()
+    { forall(&OutputGenerator::endMemberDocPunctuation); }
+    void startMemberDocConstant()
+    { forall(&OutputGenerator::startMemberDocConstant); }
+    void endMemberDocConstant()
+    { forall(&OutputGenerator::endMemberDocConstant); }
+    void startMemberDocQualifier()
+    { forall(&OutputGenerator::startMemberDocQualifier); }
+    void endMemberDocQualifier()
+    { forall(&OutputGenerator::endMemberDocQualifier); }
     void startParameterType(bool first,const char *key)
     { forall(&OutputGenerator::startParameterType,first,key); }
     void endParameterType()
Index: src/outputgen.h
===================================================================
--- src/outputgen.h	(revision 784)
+++ src/outputgen.h	(working copy)
@@ -390,10 +390,34 @@
     virtual void startTextBlock(bool) = 0;
     virtual void endTextBlock(bool) = 0;
     virtual void lastIndexPage() = 0;
+    virtual void startMemberDocOverloads() = 0;
+    virtual void endMemberDocOverloads() = 0;
+    virtual void startMemberDocProto() = 0;
+    virtual void endMemberDocProto() = 0;
     virtual void startMemberDocPrefixItem() = 0;
     virtual void endMemberDocPrefixItem() = 0;
+    virtual void startMemberDocTable() = 0;
+    virtual void endMemberDocTable(bool) = 0;
     virtual void startMemberDocName(bool) = 0;
     virtual void endMemberDocName() = 0;
+    virtual void startMemberDocSpecifier() = 0;
+    virtual void endMemberDocSpecifier() = 0;
+    virtual void startMemberDocClassName() = 0;
+    virtual void endMemberDocClassName() = 0;
+    virtual void startMemberDocMethodName() = 0;
+    virtual void endMemberDocMethodName() = 0;
+    virtual void startMemberDocFunctionName() = 0;
+    virtual void endMemberDocFunctionName() = 0;
+    virtual void startMemberDocIdentifier() = 0;
+    virtual void endMemberDocIdentifier() = 0;
+    virtual void startMemberDocParamName() = 0;
+    virtual void endMemberDocParamName() = 0;
+    virtual void startMemberDocPunctuation() = 0;
+    virtual void endMemberDocPunctuation() = 0;
+    virtual void startMemberDocConstant() = 0;
+    virtual void endMemberDocConstant() = 0;
+    virtual void startMemberDocQualifier() = 0;
+    virtual void endMemberDocQualifier() = 0;
     virtual void startParameterType(bool,const char *) = 0;
     virtual void endParameterType() = 0;
     virtual void startParameterName(bool) = 0;
Index: src/doxygen.css
===================================================================
--- src/doxygen.css	(revision 784)
+++ src/doxygen.css	(working copy)
@@ -412,7 +412,7 @@
         margin-left: 6px;
 }
 
-.memproto, dl.reflist dt {
+.memoverloads, .memproto, dl.reflist dt {
         border-top: 1px solid ##B4;
         border-left: 1px solid ##B4;
         border-right: 1px solid ##B4;
@@ -435,7 +435,11 @@
         background-image:url('nav_f.png');
         background-repeat:repeat-x;
         background-color: ##E6;
+}
 
+.memoverloads {
+	border-bottom-right-radius: 8px;
+    border-bottom-left-radius: 8px;
 }
 
 .memdoc, dl.reflist dd {
